# coding: utf-8

"""
    CEIC API

    CEIC API v2 is a new generation RESTful API that provides an easy access to CEIC's analytical and time series information, including all metadata items and time point values. It includes powerful keyword and criteria search, as well as a data feed option – retrieving only the newest time points data, in order to feed user’s own database and compare the actual changes introduced. Supported output formats include XML, JSON and CSV.  API access is secured utilizing API keys and all data transfer encrypted via HTTPS. In order to use any of the API functions, users shall generate such a key. This can be done through user's profile menu under CDMNext. Users can have only one active API key. Generating a new key will invalidate the existing one. API keys have to be included with each HTTP request, either as an `Authorization` header or as `token` query parameter.  All dates for both input parameters and output attributes are in ISO 8601 format (YYYYMMDD or YYYY-MM-DD) in order to avoid misinterpretation of numeric representations of dates and times, particularly when data are transferred between countries with different conventions for writing numeric dates and times.  <p style=\"color: red\">Security Notice: As of June 30, 2018 the CEIC API v2 will not be accessible by clients using SSL or TLS 1.0 security protocol</p>  <ul>         <li>             <a href='https://developer.isimarkets.com/en/docs/ceic/macroeconomic/python/full-guide'>CEIC Python SDK - Development Guide</a>         </li>         <li>             <a href='https://developer.isimarkets.com/en/docs/ceic/macroeconomic/php/full-guide'>CEIC PHP SDK - Development Guide</a>         </li>         <li>             <a href='https://developer.isimarkets.com/en/docs/ceic/macroeconomic/js/full-guide'>CEIC JavaScript SDK - Development Guide</a>         </li>     <li>   <a href='https://downloads.ceicdata.com/api/documentation/api-release-notes.html'>Release Notes</a>   <span>             <a href=\"https://downloads.ceicdata.com/api/documentation/api-release-notes-rss.xml\">                 <img src=\"https://downloads.ceicdata.com/api/documentation/release-notes-files/rss-logo-rectangle-35x75.png\">             </a>         </span>     </li>  </ul>  <div>     <a href='https://api-status.ceicdata.com/'>Monitor CEIC API Status</a> </div>  # noqa: E501

    OpenAPI spec version: 2.11.4
    Contact: helpdesk@ceicdata.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from ceic_api_client.api_client import ApiClient


class DefaultApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None, token=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

        self._token = token

    def dictionary_classifications_id_indicators_options(self, id, **kwargs):  # noqa: E501
        """dictionary_classifications_id_indicators_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dictionary_classifications_id_indicators_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Classification ID. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dictionary_classifications_id_indicators_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dictionary_classifications_id_indicators_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dictionary_classifications_id_indicators_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """dictionary_classifications_id_indicators_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dictionary_classifications_id_indicators_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Classification ID. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dictionary_classifications_id_indicators_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `dictionary_classifications_id_indicators_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/dictionary/classifications/{id}/indicators', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dictionary_classifications_options(self, **kwargs):  # noqa: E501
        """dictionary_classifications_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dictionary_classifications_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dictionary_classifications_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dictionary_classifications_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def dictionary_classifications_options_with_http_info(self, **kwargs):  # noqa: E501
        """dictionary_classifications_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dictionary_classifications_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dictionary_classifications_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/dictionary/classifications', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dictionary_countries_id_sources_options(self, id, **kwargs):  # noqa: E501
        """dictionary_countries_id_sources_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dictionary_countries_id_sources_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Country ISO code (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dictionary_countries_id_sources_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dictionary_countries_id_sources_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dictionary_countries_id_sources_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """dictionary_countries_id_sources_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dictionary_countries_id_sources_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Country ISO code (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dictionary_countries_id_sources_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `dictionary_countries_id_sources_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/dictionary/countries/{id}/sources', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dictionary_countries_options(self, **kwargs):  # noqa: E501
        """dictionary_countries_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dictionary_countries_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dictionary_countries_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dictionary_countries_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def dictionary_countries_options_with_http_info(self, **kwargs):  # noqa: E501
        """dictionary_countries_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dictionary_countries_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dictionary_countries_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/dictionary/countries', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dictionary_frequencies_options(self, **kwargs):  # noqa: E501
        """dictionary_frequencies_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dictionary_frequencies_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dictionary_frequencies_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dictionary_frequencies_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def dictionary_frequencies_options_with_http_info(self, **kwargs):  # noqa: E501
        """dictionary_frequencies_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dictionary_frequencies_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dictionary_frequencies_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/dictionary/frequencies', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dictionary_indicators_options(self, **kwargs):  # noqa: E501
        """dictionary_indicators_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dictionary_indicators_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dictionary_indicators_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dictionary_indicators_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def dictionary_indicators_options_with_http_info(self, **kwargs):  # noqa: E501
        """dictionary_indicators_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dictionary_indicators_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dictionary_indicators_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/dictionary/indicators', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dictionary_layouts_options(self, **kwargs):  # noqa: E501
        """dictionary_layouts_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dictionary_layouts_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dictionary_layouts_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dictionary_layouts_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def dictionary_layouts_options_with_http_info(self, **kwargs):  # noqa: E501
        """dictionary_layouts_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dictionary_layouts_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dictionary_layouts_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/dictionary/layouts', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dictionary_options(self, **kwargs):  # noqa: E501
        """dictionary_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dictionary_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dictionary_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dictionary_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def dictionary_options_with_http_info(self, **kwargs):  # noqa: E501
        """dictionary_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dictionary_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dictionary_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/dictionary', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dictionary_regions_options(self, **kwargs):  # noqa: E501
        """dictionary_regions_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dictionary_regions_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dictionary_regions_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dictionary_regions_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def dictionary_regions_options_with_http_info(self, **kwargs):  # noqa: E501
        """dictionary_regions_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dictionary_regions_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dictionary_regions_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/dictionary/regions', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dictionary_sources_options(self, **kwargs):  # noqa: E501
        """dictionary_sources_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dictionary_sources_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dictionary_sources_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dictionary_sources_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def dictionary_sources_options_with_http_info(self, **kwargs):  # noqa: E501
        """dictionary_sources_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dictionary_sources_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dictionary_sources_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/dictionary/sources', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dictionary_statuses_options(self, **kwargs):  # noqa: E501
        """dictionary_statuses_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dictionary_statuses_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dictionary_statuses_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dictionary_statuses_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def dictionary_statuses_options_with_http_info(self, **kwargs):  # noqa: E501
        """dictionary_statuses_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dictionary_statuses_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dictionary_statuses_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/dictionary/statuses', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dictionary_units_options(self, **kwargs):  # noqa: E501
        """dictionary_units_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dictionary_units_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dictionary_units_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dictionary_units_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def dictionary_units_options_with_http_info(self, **kwargs):  # noqa: E501
        """dictionary_units_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dictionary_units_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dictionary_units_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/dictionary/units', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dumps_id_options(self, id, **kwargs):  # noqa: E501
        """dumps_id_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dumps_id_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Dump ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dumps_id_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dumps_id_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dumps_id_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """dumps_id_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dumps_id_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Dump ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dumps_id_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `dumps_id_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/dumps/{id}', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dumps_options(self, **kwargs):  # noqa: E501
        """dumps_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dumps_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dumps_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dumps_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def dumps_options_with_http_info(self, **kwargs):  # noqa: E501
        """dumps_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dumps_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dumps_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/dumps', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def feeds_id_options(self, id, **kwargs):  # noqa: E501
        """feeds_id_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.feeds_id_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Feed ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.feeds_id_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.feeds_id_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def feeds_id_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """feeds_id_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.feeds_id_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Feed ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method feeds_id_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `feeds_id_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/feeds/{id}', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def feeds_options(self, **kwargs):  # noqa: E501
        """feeds_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.feeds_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.feeds_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.feeds_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def feeds_options_with_http_info(self, **kwargs):  # noqa: E501
        """feeds_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.feeds_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method feeds_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/feeds', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def filters_id_options(self, id, **kwargs):  # noqa: E501
        """filters_id_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.filters_id_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Filter ID. Accepts one or more comma separated values. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.filters_id_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.filters_id_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def filters_id_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """filters_id_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.filters_id_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Filter ID. Accepts one or more comma separated values. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method filters_id_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `filters_id_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/filters/{id}', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def filters_options(self, **kwargs):  # noqa: E501
        """filters_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.filters_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.filters_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.filters_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def filters_options_with_http_info(self, **kwargs):  # noqa: E501
        """filters_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.filters_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method filters_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/filters', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def impersonate_token_options(self, employee_token, user_id, application, **kwargs):  # noqa: E501
        """impersonate_token_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.impersonate_token_options(employee_token, user_id, application, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str employee_token: Impersonate API token generated on CAS service (required)
        :param str user_id: User Id (required)
        :param str application: Application ID (required)
        :param float expire_after: Token will be expired after `expire_after` in seconds
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.impersonate_token_options_with_http_info(employee_token, user_id, application, **kwargs)  # noqa: E501
        else:
            (data) = self.impersonate_token_options_with_http_info(employee_token, user_id, application, **kwargs)  # noqa: E501
            return data

    def impersonate_token_options_with_http_info(self, employee_token, user_id, application, **kwargs):  # noqa: E501
        """impersonate_token_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.impersonate_token_options_with_http_info(employee_token, user_id, application, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str employee_token: Impersonate API token generated on CAS service (required)
        :param str user_id: User Id (required)
        :param str application: Application ID (required)
        :param float expire_after: Token will be expired after `expire_after` in seconds
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['employee_token', 'user_id', 'application', 'expire_after']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method impersonate_token_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'employee_token' is set
        if self.api_client.client_side_validation and ('employee_token' not in params or
                                                       params['employee_token'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `employee_token` when calling `impersonate_token_options`")  # noqa: E501
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `impersonate_token_options`")  # noqa: E501
        # verify the required parameter 'application' is set
        if self.api_client.client_side_validation and ('application' not in params or
                                                       params['application'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `application` when calling `impersonate_token_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'employee_token' in params:
            form_params.append(('employee_token', params['employee_token']))  # noqa: E501
        if 'user_id' in params:
            form_params.append(('user_id', params['user_id']))  # noqa: E501
        if 'application' in params:
            form_params.append(('application', params['application']))  # noqa: E501
        if 'expire_after' in params:
            form_params.append(('expire_after', params['expire_after']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/impersonate/token', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def insights_categories_emis_options(self, **kwargs):  # noqa: E501
        """insights_categories_emis_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insights_categories_emis_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.insights_categories_emis_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.insights_categories_emis_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def insights_categories_emis_options_with_http_info(self, **kwargs):  # noqa: E501
        """insights_categories_emis_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insights_categories_emis_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method insights_categories_emis_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/insights/categories/emis', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def insights_categories_gallery_options(self, **kwargs):  # noqa: E501
        """insights_categories_gallery_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insights_categories_gallery_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.insights_categories_gallery_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.insights_categories_gallery_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def insights_categories_gallery_options_with_http_info(self, **kwargs):  # noqa: E501
        """insights_categories_gallery_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insights_categories_gallery_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method insights_categories_gallery_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/insights/categories/gallery', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def insights_categories_options(self, **kwargs):  # noqa: E501
        """insights_categories_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insights_categories_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.insights_categories_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.insights_categories_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def insights_categories_options_with_http_info(self, **kwargs):  # noqa: E501
        """insights_categories_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insights_categories_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method insights_categories_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/insights/categories', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def insights_id_download_file_format_options(self, id, file_format, **kwargs):  # noqa: E501
        """insights_id_download_file_format_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insights_id_download_file_format_options(id, file_format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Insight ID (required)
        :param str file_format: Insight report file format. Available formats: `xlsx`, `pdf` (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param bool ignore_cache: New file will be generated
        :param str adjust_columns: No adjust or wrap text in XLSX cell
        :param date start_date: Limits the start date after which the time-points will be returned.
        :param date end_date: Limits the end date before which the time-points will be returned.
        :param int count: Limit the amount of latest time-points returned, by the number specified.
        :param str blank_observations: If set to true, will return empty time-points which oterwise are omitted.
        :param str orientation: Columns/rows orientation
        :param str order: Sort order - Asc/Desc
        :param float decimal_places: Decimal places for the time-points values
        :param str date_format: Time-points date format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.insights_id_download_file_format_options_with_http_info(id, file_format, **kwargs)  # noqa: E501
        else:
            (data) = self.insights_id_download_file_format_options_with_http_info(id, file_format, **kwargs)  # noqa: E501
            return data

    def insights_id_download_file_format_options_with_http_info(self, id, file_format, **kwargs):  # noqa: E501
        """insights_id_download_file_format_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insights_id_download_file_format_options_with_http_info(id, file_format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Insight ID (required)
        :param str file_format: Insight report file format. Available formats: `xlsx`, `pdf` (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param bool ignore_cache: New file will be generated
        :param str adjust_columns: No adjust or wrap text in XLSX cell
        :param date start_date: Limits the start date after which the time-points will be returned.
        :param date end_date: Limits the end date before which the time-points will be returned.
        :param int count: Limit the amount of latest time-points returned, by the number specified.
        :param str blank_observations: If set to true, will return empty time-points which oterwise are omitted.
        :param str orientation: Columns/rows orientation
        :param str order: Sort order - Asc/Desc
        :param float decimal_places: Decimal places for the time-points values
        :param str date_format: Time-points date format
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'file_format', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'ignore_cache', 'adjust_columns', 'start_date', 'end_date', 'count', 'blank_observations', 'orientation', 'order', 'decimal_places', 'date_format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method insights_id_download_file_format_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `insights_id_download_file_format_options`")  # noqa: E501
        # verify the required parameter 'file_format' is set
        if self.api_client.client_side_validation and ('file_format' not in params or
                                                       params['file_format'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `file_format` when calling `insights_id_download_file_format_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'file_format' in params:
            path_params['file_format'] = params['file_format']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'ignore_cache' in params:
            query_params.append(('ignore_cache', params['ignore_cache']))  # noqa: E501
        if 'adjust_columns' in params:
            query_params.append(('adjust_columns', params['adjust_columns']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'blank_observations' in params:
            query_params.append(('blank_observations', params['blank_observations']))  # noqa: E501
        if 'orientation' in params:
            query_params.append(('orientation', params['orientation']))  # noqa: E501
        if 'order' in params:
            query_params.append(('order', params['order']))  # noqa: E501
        if 'decimal_places' in params:
            query_params.append(('decimal_places', params['decimal_places']))  # noqa: E501
        if 'date_format' in params:
            query_params.append(('date_format', params['date_format']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/insights/{id}/download/{file_format}', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def insights_id_options(self, id, **kwargs):  # noqa: E501
        """insights_id_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insights_id_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Insight ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.insights_id_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.insights_id_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def insights_id_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """insights_id_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insights_id_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Insight ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method insights_id_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `insights_id_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/insights/{id}', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def insights_id_series_data_options(self, id, **kwargs):  # noqa: E501
        """insights_id_series_data_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insights_id_series_data_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Insight ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param int count: Limit the amount of latest time-points returned, by the number specified.
        :param date start_date: Limits the start date after which the time-points will be returned.
        :param date end_date: Limits the end date before which the time-points will be returned.
        :param datetime updated_after: Returns only the updated time-points after the date specified.
        :param bool blank_observations: If it's set to true, empty time-points will be returned
        :param str time_points_status: Time points filter. One or more comma separated status code values. When not explicitly set, defaults to T. T - Active X - Deleted
        :param float limit: Number of records to return in the range 1 - 100. Default is 100.
        :param float offset: The offset from which the records will be returned. Used to get the next set of records when the limit is reached.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.insights_id_series_data_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.insights_id_series_data_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def insights_id_series_data_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """insights_id_series_data_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insights_id_series_data_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Insight ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param int count: Limit the amount of latest time-points returned, by the number specified.
        :param date start_date: Limits the start date after which the time-points will be returned.
        :param date end_date: Limits the end date before which the time-points will be returned.
        :param datetime updated_after: Returns only the updated time-points after the date specified.
        :param bool blank_observations: If it's set to true, empty time-points will be returned
        :param str time_points_status: Time points filter. One or more comma separated status code values. When not explicitly set, defaults to T. T - Active X - Deleted
        :param float limit: Number of records to return in the range 1 - 100. Default is 100.
        :param float offset: The offset from which the records will be returned. Used to get the next set of records when the limit is reached.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'count', 'start_date', 'end_date', 'updated_after', 'blank_observations', 'time_points_status', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method insights_id_series_data_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `insights_id_series_data_options`")  # noqa: E501

        if self.api_client.client_side_validation and ('limit' in params and params['limit'] > 100):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `insights_id_series_data_options`, must be a value less than or equal to `100`")  # noqa: E501
        if self.api_client.client_side_validation and ('limit' in params and params['limit'] < 1):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `insights_id_series_data_options`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'updated_after' in params:
            query_params.append(('updated_after', params['updated_after']))  # noqa: E501
        if 'blank_observations' in params:
            query_params.append(('blank_observations', params['blank_observations']))  # noqa: E501
        if 'time_points_status' in params:
            query_params.append(('time_points_status', params['time_points_status']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/insights/{id}/series/data', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def insights_id_series_metadata_options(self, id, **kwargs):  # noqa: E501
        """insights_id_series_metadata_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insights_id_series_metadata_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Insight ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param bool with_replacements_metadata: If it is `true` result will contain replacements metadata not only list of id`s
        :param bool forecast_only: If it is `true` result will only contain series with forecast
        :param bool with_release_only: If it is `true` result will only contain series with released schedule
        :param bool with_replacements_only: If it is `true` result will only contain series with suggestions
        :param bool with_observations_only: If it is `true` result will not contain series without observations
        :param bool with_continuous_only: If set to `true` results will contain only series with available historical extensions
        :param float limit: Number of records to return in the range 1 - 100. Default is 100.
        :param float offset: The offset from which the records will be returned. Used to get the next set of records when the limit is reached.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.insights_id_series_metadata_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.insights_id_series_metadata_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def insights_id_series_metadata_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """insights_id_series_metadata_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insights_id_series_metadata_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Insight ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param bool with_replacements_metadata: If it is `true` result will contain replacements metadata not only list of id`s
        :param bool forecast_only: If it is `true` result will only contain series with forecast
        :param bool with_release_only: If it is `true` result will only contain series with released schedule
        :param bool with_replacements_only: If it is `true` result will only contain series with suggestions
        :param bool with_observations_only: If it is `true` result will not contain series without observations
        :param bool with_continuous_only: If set to `true` results will contain only series with available historical extensions
        :param float limit: Number of records to return in the range 1 - 100. Default is 100.
        :param float offset: The offset from which the records will be returned. Used to get the next set of records when the limit is reached.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'with_replacements_metadata', 'forecast_only', 'with_release_only', 'with_replacements_only', 'with_observations_only', 'with_continuous_only', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method insights_id_series_metadata_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `insights_id_series_metadata_options`")  # noqa: E501

        if self.api_client.client_side_validation and ('limit' in params and params['limit'] > 100):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `insights_id_series_metadata_options`, must be a value less than or equal to `100`")  # noqa: E501
        if self.api_client.client_side_validation and ('limit' in params and params['limit'] < 1):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `insights_id_series_metadata_options`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'with_replacements_metadata' in params:
            query_params.append(('with_replacements_metadata', params['with_replacements_metadata']))  # noqa: E501
        if 'forecast_only' in params:
            query_params.append(('forecast_only', params['forecast_only']))  # noqa: E501
        if 'with_release_only' in params:
            query_params.append(('with_release_only', params['with_release_only']))  # noqa: E501
        if 'with_replacements_only' in params:
            query_params.append(('with_replacements_only', params['with_replacements_only']))  # noqa: E501
        if 'with_observations_only' in params:
            query_params.append(('with_observations_only', params['with_observations_only']))  # noqa: E501
        if 'with_continuous_only' in params:
            query_params.append(('with_continuous_only', params['with_continuous_only']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/insights/{id}/series/metadata', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def insights_id_series_options(self, id, **kwargs):  # noqa: E501
        """insights_id_series_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insights_id_series_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Insight ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param int count: Limit the amount of latest time-points returned, by the number specified.
        :param date start_date: Limits the start date after which the time-points will be returned.
        :param date end_date: Limits the end date before which the time-points will be returned.
        :param datetime updated_after: Returns only the updated time-points after the date specified.
        :param bool blank_observations: If it's set to true, empty time-points will be returned
        :param str time_points_status: Time points filter. One or more comma separated status code values. When not explicitly set, defaults to T. T - Active X - Deleted
        :param bool with_replacements_metadata: If it is `true` result will contain replacements metadata not only list of id`s
        :param bool forecast_only: If it is `true` result will only contain series with forecast
        :param bool with_release_only: If it is `true` result will only contain series with released schedule
        :param bool with_replacements_only: If it is `true` result will only contain series with suggestions
        :param bool with_observations_only: If it is `true` result will not contain series without observations
        :param bool with_continuous_only: If set to `true` results will contain only series with available historical extensions
        :param float limit: Number of records to return in the range 1 - 100. Default is 100.
        :param float offset: The offset from which the records will be returned. Used to get the next set of records when the limit is reached.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.insights_id_series_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.insights_id_series_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def insights_id_series_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """insights_id_series_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insights_id_series_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Insight ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param int count: Limit the amount of latest time-points returned, by the number specified.
        :param date start_date: Limits the start date after which the time-points will be returned.
        :param date end_date: Limits the end date before which the time-points will be returned.
        :param datetime updated_after: Returns only the updated time-points after the date specified.
        :param bool blank_observations: If it's set to true, empty time-points will be returned
        :param str time_points_status: Time points filter. One or more comma separated status code values. When not explicitly set, defaults to T. T - Active X - Deleted
        :param bool with_replacements_metadata: If it is `true` result will contain replacements metadata not only list of id`s
        :param bool forecast_only: If it is `true` result will only contain series with forecast
        :param bool with_release_only: If it is `true` result will only contain series with released schedule
        :param bool with_replacements_only: If it is `true` result will only contain series with suggestions
        :param bool with_observations_only: If it is `true` result will not contain series without observations
        :param bool with_continuous_only: If set to `true` results will contain only series with available historical extensions
        :param float limit: Number of records to return in the range 1 - 100. Default is 100.
        :param float offset: The offset from which the records will be returned. Used to get the next set of records when the limit is reached.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'count', 'start_date', 'end_date', 'updated_after', 'blank_observations', 'time_points_status', 'with_replacements_metadata', 'forecast_only', 'with_release_only', 'with_replacements_only', 'with_observations_only', 'with_continuous_only', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method insights_id_series_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `insights_id_series_options`")  # noqa: E501

        if self.api_client.client_side_validation and ('limit' in params and params['limit'] > 100):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `insights_id_series_options`, must be a value less than or equal to `100`")  # noqa: E501
        if self.api_client.client_side_validation and ('limit' in params and params['limit'] < 1):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `insights_id_series_options`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'updated_after' in params:
            query_params.append(('updated_after', params['updated_after']))  # noqa: E501
        if 'blank_observations' in params:
            query_params.append(('blank_observations', params['blank_observations']))  # noqa: E501
        if 'time_points_status' in params:
            query_params.append(('time_points_status', params['time_points_status']))  # noqa: E501
        if 'with_replacements_metadata' in params:
            query_params.append(('with_replacements_metadata', params['with_replacements_metadata']))  # noqa: E501
        if 'forecast_only' in params:
            query_params.append(('forecast_only', params['forecast_only']))  # noqa: E501
        if 'with_release_only' in params:
            query_params.append(('with_release_only', params['with_release_only']))  # noqa: E501
        if 'with_replacements_only' in params:
            query_params.append(('with_replacements_only', params['with_replacements_only']))  # noqa: E501
        if 'with_observations_only' in params:
            query_params.append(('with_observations_only', params['with_observations_only']))  # noqa: E501
        if 'with_continuous_only' in params:
            query_params.append(('with_continuous_only', params['with_continuous_only']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/insights/{id}/series', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def insights_options(self, **kwargs):  # noqa: E501
        """insights_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insights_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.insights_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.insights_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def insights_options_with_http_info(self, **kwargs):  # noqa: E501
        """insights_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insights_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method insights_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/insights', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def insights_search_options(self, **kwargs):  # noqa: E501
        """insights_search_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insights_search_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.insights_search_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.insights_search_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def insights_search_options_with_http_info(self, **kwargs):  # noqa: E501
        """insights_search_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insights_search_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method insights_search_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/insights/search', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def insights_series_series_id_data_options(self, series_id, **kwargs):  # noqa: E501
        """insights_series_series_id_data_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insights_series_series_id_data_options(series_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str series_id: Insight Series ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param int count: Limit the amount of latest time-points returned, by the number specified.
        :param date start_date: Limits the start date after which the time-points will be returned.
        :param date end_date: Limits the end date before which the time-points will be returned.
        :param datetime updated_after: Returns only the updated time-points after the date specified.
        :param bool blank_observations: If it's set to true, empty time-points will be returned
        :param str time_points_status: Time points filter. One or more comma separated status code values. When not explicitly set, defaults to T. T - Active X - Deleted
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.insights_series_series_id_data_options_with_http_info(series_id, **kwargs)  # noqa: E501
        else:
            (data) = self.insights_series_series_id_data_options_with_http_info(series_id, **kwargs)  # noqa: E501
            return data

    def insights_series_series_id_data_options_with_http_info(self, series_id, **kwargs):  # noqa: E501
        """insights_series_series_id_data_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insights_series_series_id_data_options_with_http_info(series_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str series_id: Insight Series ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param int count: Limit the amount of latest time-points returned, by the number specified.
        :param date start_date: Limits the start date after which the time-points will be returned.
        :param date end_date: Limits the end date before which the time-points will be returned.
        :param datetime updated_after: Returns only the updated time-points after the date specified.
        :param bool blank_observations: If it's set to true, empty time-points will be returned
        :param str time_points_status: Time points filter. One or more comma separated status code values. When not explicitly set, defaults to T. T - Active X - Deleted
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['series_id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'count', 'start_date', 'end_date', 'updated_after', 'blank_observations', 'time_points_status']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method insights_series_series_id_data_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'series_id' is set
        if self.api_client.client_side_validation and ('series_id' not in params or
                                                       params['series_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `series_id` when calling `insights_series_series_id_data_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'series_id' in params:
            path_params['series_id'] = params['series_id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'updated_after' in params:
            query_params.append(('updated_after', params['updated_after']))  # noqa: E501
        if 'blank_observations' in params:
            query_params.append(('blank_observations', params['blank_observations']))  # noqa: E501
        if 'time_points_status' in params:
            query_params.append(('time_points_status', params['time_points_status']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/insights/series/{series_id}/data', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def insights_series_series_id_metadata_options(self, series_id, **kwargs):  # noqa: E501
        """insights_series_series_id_metadata_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insights_series_series_id_metadata_options(series_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str series_id: Insight Series ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param bool with_replacements_metadata: If it is `true` result will contain replacements metadata not only list of id`s
        :param bool forecast_only: If it is `true` result will only contain series with forecast
        :param bool with_release_only: If it is `true` result will only contain series with released schedule
        :param bool with_replacements_only: If it is `true` result will only contain series with suggestions
        :param bool with_observations_only: If it is `true` result will not contain series without observations
        :param bool with_continuous_only: If set to `true` results will contain only series with available historical extensions
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.insights_series_series_id_metadata_options_with_http_info(series_id, **kwargs)  # noqa: E501
        else:
            (data) = self.insights_series_series_id_metadata_options_with_http_info(series_id, **kwargs)  # noqa: E501
            return data

    def insights_series_series_id_metadata_options_with_http_info(self, series_id, **kwargs):  # noqa: E501
        """insights_series_series_id_metadata_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insights_series_series_id_metadata_options_with_http_info(series_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str series_id: Insight Series ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param bool with_replacements_metadata: If it is `true` result will contain replacements metadata not only list of id`s
        :param bool forecast_only: If it is `true` result will only contain series with forecast
        :param bool with_release_only: If it is `true` result will only contain series with released schedule
        :param bool with_replacements_only: If it is `true` result will only contain series with suggestions
        :param bool with_observations_only: If it is `true` result will not contain series without observations
        :param bool with_continuous_only: If set to `true` results will contain only series with available historical extensions
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['series_id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'with_replacements_metadata', 'forecast_only', 'with_release_only', 'with_replacements_only', 'with_observations_only', 'with_continuous_only']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method insights_series_series_id_metadata_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'series_id' is set
        if self.api_client.client_side_validation and ('series_id' not in params or
                                                       params['series_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `series_id` when calling `insights_series_series_id_metadata_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'series_id' in params:
            path_params['series_id'] = params['series_id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'with_replacements_metadata' in params:
            query_params.append(('with_replacements_metadata', params['with_replacements_metadata']))  # noqa: E501
        if 'forecast_only' in params:
            query_params.append(('forecast_only', params['forecast_only']))  # noqa: E501
        if 'with_release_only' in params:
            query_params.append(('with_release_only', params['with_release_only']))  # noqa: E501
        if 'with_replacements_only' in params:
            query_params.append(('with_replacements_only', params['with_replacements_only']))  # noqa: E501
        if 'with_observations_only' in params:
            query_params.append(('with_observations_only', params['with_observations_only']))  # noqa: E501
        if 'with_continuous_only' in params:
            query_params.append(('with_continuous_only', params['with_continuous_only']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/insights/series/{series_id}/metadata', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def insights_series_series_id_options(self, series_id, **kwargs):  # noqa: E501
        """insights_series_series_id_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insights_series_series_id_options(series_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str series_id: Insight Series ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param int count: Limit the amount of latest time-points returned, by the number specified.
        :param date start_date: Limits the start date after which the time-points will be returned.
        :param date end_date: Limits the end date before which the time-points will be returned.
        :param datetime updated_after: Returns only the updated time-points after the date specified.
        :param bool blank_observations: If it's set to true, empty time-points will be returned
        :param str time_points_status: Time points filter. One or more comma separated status code values. When not explicitly set, defaults to T. T - Active X - Deleted
        :param bool with_replacements_metadata: If it is `true` result will contain replacements metadata not only list of id`s
        :param bool forecast_only: If it is `true` result will only contain series with forecast
        :param bool with_release_only: If it is `true` result will only contain series with released schedule
        :param bool with_replacements_only: If it is `true` result will only contain series with suggestions
        :param bool with_observations_only: If it is `true` result will not contain series without observations
        :param bool with_continuous_only: If set to `true` results will contain only series with available historical extensions
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.insights_series_series_id_options_with_http_info(series_id, **kwargs)  # noqa: E501
        else:
            (data) = self.insights_series_series_id_options_with_http_info(series_id, **kwargs)  # noqa: E501
            return data

    def insights_series_series_id_options_with_http_info(self, series_id, **kwargs):  # noqa: E501
        """insights_series_series_id_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insights_series_series_id_options_with_http_info(series_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str series_id: Insight Series ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param int count: Limit the amount of latest time-points returned, by the number specified.
        :param date start_date: Limits the start date after which the time-points will be returned.
        :param date end_date: Limits the end date before which the time-points will be returned.
        :param datetime updated_after: Returns only the updated time-points after the date specified.
        :param bool blank_observations: If it's set to true, empty time-points will be returned
        :param str time_points_status: Time points filter. One or more comma separated status code values. When not explicitly set, defaults to T. T - Active X - Deleted
        :param bool with_replacements_metadata: If it is `true` result will contain replacements metadata not only list of id`s
        :param bool forecast_only: If it is `true` result will only contain series with forecast
        :param bool with_release_only: If it is `true` result will only contain series with released schedule
        :param bool with_replacements_only: If it is `true` result will only contain series with suggestions
        :param bool with_observations_only: If it is `true` result will not contain series without observations
        :param bool with_continuous_only: If set to `true` results will contain only series with available historical extensions
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['series_id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'count', 'start_date', 'end_date', 'updated_after', 'blank_observations', 'time_points_status', 'with_replacements_metadata', 'forecast_only', 'with_release_only', 'with_replacements_only', 'with_observations_only', 'with_continuous_only']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method insights_series_series_id_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'series_id' is set
        if self.api_client.client_side_validation and ('series_id' not in params or
                                                       params['series_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `series_id` when calling `insights_series_series_id_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'series_id' in params:
            path_params['series_id'] = params['series_id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'updated_after' in params:
            query_params.append(('updated_after', params['updated_after']))  # noqa: E501
        if 'blank_observations' in params:
            query_params.append(('blank_observations', params['blank_observations']))  # noqa: E501
        if 'time_points_status' in params:
            query_params.append(('time_points_status', params['time_points_status']))  # noqa: E501
        if 'with_replacements_metadata' in params:
            query_params.append(('with_replacements_metadata', params['with_replacements_metadata']))  # noqa: E501
        if 'forecast_only' in params:
            query_params.append(('forecast_only', params['forecast_only']))  # noqa: E501
        if 'with_release_only' in params:
            query_params.append(('with_release_only', params['with_release_only']))  # noqa: E501
        if 'with_replacements_only' in params:
            query_params.append(('with_replacements_only', params['with_replacements_only']))  # noqa: E501
        if 'with_observations_only' in params:
            query_params.append(('with_observations_only', params['with_observations_only']))  # noqa: E501
        if 'with_continuous_only' in params:
            query_params.append(('with_continuous_only', params['with_continuous_only']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/insights/series/{series_id}', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def internal_series_id_internal_remarks_options(self, id, **kwargs):  # noqa: E501
        """internal_series_id_internal_remarks_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.internal_series_id_internal_remarks_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Series ID or Series Code to return. Accepts only one series ID or series Code. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str vintage_revision_date: When specified will return vintages snapshot at the specified revision date (YYYY-MM-DD).
        :param bool with_replacements_metadata: If it is `true` result will contain replacements metadata not only list of id`s
        :param bool forecast_only: If it is `true` result will only contain series with forecast
        :param bool with_release_only: If it is `true` result will only contain series with released schedule
        :param bool with_replacements_only: If it is `true` result will only contain series with suggestions
        :param bool with_observations_only: If it is `true` result will not contain series without observations
        :param bool with_continuous_only: If set to `true` results will contain only series with available historical extensions
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.internal_series_id_internal_remarks_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.internal_series_id_internal_remarks_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def internal_series_id_internal_remarks_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """internal_series_id_internal_remarks_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.internal_series_id_internal_remarks_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Series ID or Series Code to return. Accepts only one series ID or series Code. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str vintage_revision_date: When specified will return vintages snapshot at the specified revision date (YYYY-MM-DD).
        :param bool with_replacements_metadata: If it is `true` result will contain replacements metadata not only list of id`s
        :param bool forecast_only: If it is `true` result will only contain series with forecast
        :param bool with_release_only: If it is `true` result will only contain series with released schedule
        :param bool with_replacements_only: If it is `true` result will only contain series with suggestions
        :param bool with_observations_only: If it is `true` result will not contain series without observations
        :param bool with_continuous_only: If set to `true` results will contain only series with available historical extensions
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'vintage_revision_date', 'with_replacements_metadata', 'forecast_only', 'with_release_only', 'with_replacements_only', 'with_observations_only', 'with_continuous_only']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method internal_series_id_internal_remarks_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `internal_series_id_internal_remarks_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'vintage_revision_date' in params:
            query_params.append(('vintage_revision_date', params['vintage_revision_date']))  # noqa: E501
        if 'with_replacements_metadata' in params:
            query_params.append(('with_replacements_metadata', params['with_replacements_metadata']))  # noqa: E501
        if 'forecast_only' in params:
            query_params.append(('forecast_only', params['forecast_only']))  # noqa: E501
        if 'with_release_only' in params:
            query_params.append(('with_release_only', params['with_release_only']))  # noqa: E501
        if 'with_replacements_only' in params:
            query_params.append(('with_replacements_only', params['with_replacements_only']))  # noqa: E501
        if 'with_observations_only' in params:
            query_params.append(('with_observations_only', params['with_observations_only']))  # noqa: E501
        if 'with_continuous_only' in params:
            query_params.append(('with_continuous_only', params['with_continuous_only']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/internal/series/{id}/internal_remarks', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def layout_databases_id_topics_options(self, id, **kwargs):  # noqa: E501
        """layout_databases_id_topics_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.layout_databases_id_topics_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Database ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str keyword: Search term. One or more keywords. May contain special words further controlling the search results. Keyword search tips: `Retail Sales` - Show series with both keywords while the sequence of keywords is irrelevant. Equivalent to search Sales Retail `Retail AND Sales` - Show results: series with terms of Retail AND Sales, regardless of the sequence. E. g. Retail Sales, Automobile Sales Retail `Retail;Sales` - Show series with either keyword and series with both keywords while the sequence of keywords is irrelevant, equivalent to search: Sales;Retail `Retail OR Sales` - Show results: series with terms of Retail OR Sales, regardless of the sequence. E. g. Retail Sales, Retail Trade, Sales Price, Motor Vehicle Sales `Retail NOT Sales` - Narrow a search by excluding specific terms while the sequence of keywords is relevant. Show results: series with terms that include Retail, but NOT Sales. E. g. Retail Trade, Retail Price, Retail Bank `Retail Sales NOT (Hong Kong)` - Narrow a search by excluding a set of words in parentheses while the sequence of keywords in parentheses is irrelevant, equivalent to search: Retail Sales NOT (Hong Kong). Show results: series with terms that include Retail Sales, but NOT Hong Kong, such as Retail Sales YoY: China, Retail Sales YoY: United States
        :param bool strict_keyword_search: When true, will make a strict keywords search instead of fuzzy search.
        :param list[str] frequency: Frequency filter. One or more comma separated frequency code values. D - Daily W - Weekly M - Monthly Q - Quarterly H - Semi-annual Y - Annual Z - Quinquennially T - Decadal
        :param list[str] country: **DEPRECATED. Please use `geo` parameter.** Country filter. One or more comma separated country code values. See related Dictionary function to get the full list of accepted countries.
        :param list[str] source: Source filter. One or more comma separated source code values. See related Dictionary function to get the full list of accepted sources.
        :param list[str] unit: Unit filter. One or more comma separated unit code values. See related Dictionary function to get the full list of accepted units.
        :param list[str] indicator: Indicator filter. One or more comma separated indicator code values. See related Dictionary function to get full list of accepted indicators. The use the new indicators ids is recommended because the old ones are deprecated and going to be removed in the near future!
        :param list[str] region: Region filter. One or more comma separated region code values. See related Dictionary function to get the full list of accepted regions.
        :param bool subscribed_only: Show only results for subscribed series when set to `true`. By default show results for all the series found.
        :param bool key_only: Show only 'key' series when set to `true`.
        :param bool new_only: Show only series created less than 1 month ago when set to `true`.
        :param bool name_only: This filter related with the `keyword` filter. If it's `true` keyword search will be searched only in series name instead of all series attributes.
        :param date start_date_before: Will return series with first observation before `start_date_before`
        :param date end_date_after: Will return series with last observation after `end_date_after`
        :param date created_after: Will return entries created after `created_after` date
        :param date updated_after: Will return series last time updated after `updated_after` date and time
        :param date timepoints_updated_after:  Will return series containing timepoints' last time updated after updated_after date and time
        :param list[str] geo: Geo filter. One or more comma separated geo id values. See related Dictionary function to get the full list of accepted geo ids.
        :param list[str] status: Status filter. One or more comma separated status code values. When not explicitly set, defaults to T.  T - Active C - Discontinued B - Rebased D - On-Demand
        :param list[str] filter_id: Filter ID used to define a subset of data over which the search will be executed. When combined with additional search criterion, the result will be an intesection of both.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.layout_databases_id_topics_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.layout_databases_id_topics_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def layout_databases_id_topics_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """layout_databases_id_topics_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.layout_databases_id_topics_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Database ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str keyword: Search term. One or more keywords. May contain special words further controlling the search results. Keyword search tips: `Retail Sales` - Show series with both keywords while the sequence of keywords is irrelevant. Equivalent to search Sales Retail `Retail AND Sales` - Show results: series with terms of Retail AND Sales, regardless of the sequence. E. g. Retail Sales, Automobile Sales Retail `Retail;Sales` - Show series with either keyword and series with both keywords while the sequence of keywords is irrelevant, equivalent to search: Sales;Retail `Retail OR Sales` - Show results: series with terms of Retail OR Sales, regardless of the sequence. E. g. Retail Sales, Retail Trade, Sales Price, Motor Vehicle Sales `Retail NOT Sales` - Narrow a search by excluding specific terms while the sequence of keywords is relevant. Show results: series with terms that include Retail, but NOT Sales. E. g. Retail Trade, Retail Price, Retail Bank `Retail Sales NOT (Hong Kong)` - Narrow a search by excluding a set of words in parentheses while the sequence of keywords in parentheses is irrelevant, equivalent to search: Retail Sales NOT (Hong Kong). Show results: series with terms that include Retail Sales, but NOT Hong Kong, such as Retail Sales YoY: China, Retail Sales YoY: United States
        :param bool strict_keyword_search: When true, will make a strict keywords search instead of fuzzy search.
        :param list[str] frequency: Frequency filter. One or more comma separated frequency code values. D - Daily W - Weekly M - Monthly Q - Quarterly H - Semi-annual Y - Annual Z - Quinquennially T - Decadal
        :param list[str] country: **DEPRECATED. Please use `geo` parameter.** Country filter. One or more comma separated country code values. See related Dictionary function to get the full list of accepted countries.
        :param list[str] source: Source filter. One or more comma separated source code values. See related Dictionary function to get the full list of accepted sources.
        :param list[str] unit: Unit filter. One or more comma separated unit code values. See related Dictionary function to get the full list of accepted units.
        :param list[str] indicator: Indicator filter. One or more comma separated indicator code values. See related Dictionary function to get full list of accepted indicators. The use the new indicators ids is recommended because the old ones are deprecated and going to be removed in the near future!
        :param list[str] region: Region filter. One or more comma separated region code values. See related Dictionary function to get the full list of accepted regions.
        :param bool subscribed_only: Show only results for subscribed series when set to `true`. By default show results for all the series found.
        :param bool key_only: Show only 'key' series when set to `true`.
        :param bool new_only: Show only series created less than 1 month ago when set to `true`.
        :param bool name_only: This filter related with the `keyword` filter. If it's `true` keyword search will be searched only in series name instead of all series attributes.
        :param date start_date_before: Will return series with first observation before `start_date_before`
        :param date end_date_after: Will return series with last observation after `end_date_after`
        :param date created_after: Will return entries created after `created_after` date
        :param date updated_after: Will return series last time updated after `updated_after` date and time
        :param date timepoints_updated_after:  Will return series containing timepoints' last time updated after updated_after date and time
        :param list[str] geo: Geo filter. One or more comma separated geo id values. See related Dictionary function to get the full list of accepted geo ids.
        :param list[str] status: Status filter. One or more comma separated status code values. When not explicitly set, defaults to T.  T - Active C - Discontinued B - Rebased D - On-Demand
        :param list[str] filter_id: Filter ID used to define a subset of data over which the search will be executed. When combined with additional search criterion, the result will be an intesection of both.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'keyword', 'strict_keyword_search', 'frequency', 'country', 'source', 'unit', 'indicator', 'region', 'subscribed_only', 'key_only', 'new_only', 'name_only', 'start_date_before', 'end_date_after', 'created_after', 'updated_after', 'timepoints_updated_after', 'geo', 'status', 'filter_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method layout_databases_id_topics_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `layout_databases_id_topics_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'keyword' in params:
            query_params.append(('keyword', params['keyword']))  # noqa: E501
        if 'strict_keyword_search' in params:
            query_params.append(('strict_keyword_search', params['strict_keyword_search']))  # noqa: E501
        if 'frequency' in params:
            query_params.append(('frequency', params['frequency']))  # noqa: E501
            collection_formats['frequency'] = 'csv'  # noqa: E501
        if 'country' in params:
            query_params.append(('country', params['country']))  # noqa: E501
            collection_formats['country'] = 'csv'  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
            collection_formats['source'] = 'csv'  # noqa: E501
        if 'unit' in params:
            query_params.append(('unit', params['unit']))  # noqa: E501
            collection_formats['unit'] = 'csv'  # noqa: E501
        if 'indicator' in params:
            query_params.append(('indicator', params['indicator']))  # noqa: E501
            collection_formats['indicator'] = 'csv'  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
            collection_formats['region'] = 'csv'  # noqa: E501
        if 'subscribed_only' in params:
            query_params.append(('subscribed_only', params['subscribed_only']))  # noqa: E501
        if 'key_only' in params:
            query_params.append(('key_only', params['key_only']))  # noqa: E501
        if 'new_only' in params:
            query_params.append(('new_only', params['new_only']))  # noqa: E501
        if 'name_only' in params:
            query_params.append(('name_only', params['name_only']))  # noqa: E501
        if 'start_date_before' in params:
            query_params.append(('start_date_before', params['start_date_before']))  # noqa: E501
        if 'end_date_after' in params:
            query_params.append(('end_date_after', params['end_date_after']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('created_after', params['created_after']))  # noqa: E501
        if 'updated_after' in params:
            query_params.append(('updated_after', params['updated_after']))  # noqa: E501
        if 'timepoints_updated_after' in params:
            query_params.append(('timepoints_updated_after', params['timepoints_updated_after']))  # noqa: E501
        if 'geo' in params:
            query_params.append(('geo', params['geo']))  # noqa: E501
            collection_formats['geo'] = 'csv'  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
            collection_formats['status'] = 'csv'  # noqa: E501
        if 'filter_id' in params:
            query_params.append(('filter_id', params['filter_id']))  # noqa: E501
            collection_formats['filter_id'] = 'csv'  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/layout/databases/{id}/topics', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def layout_databases_options(self, **kwargs):  # noqa: E501
        """layout_databases_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.layout_databases_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.layout_databases_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.layout_databases_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def layout_databases_options_with_http_info(self, **kwargs):  # noqa: E501
        """layout_databases_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.layout_databases_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method layout_databases_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/layout/databases', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def layout_node_code_footnote_download_file_name_options(self, node_code, file_name, **kwargs):  # noqa: E501
        """layout_node_code_footnote_download_file_name_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.layout_node_code_footnote_download_file_name_options(node_code, file_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_code: Node Code - Database ID, Topic ID, Section ID or Table ID (required)
        :param str file_name: Resource file name (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.layout_node_code_footnote_download_file_name_options_with_http_info(node_code, file_name, **kwargs)  # noqa: E501
        else:
            (data) = self.layout_node_code_footnote_download_file_name_options_with_http_info(node_code, file_name, **kwargs)  # noqa: E501
            return data

    def layout_node_code_footnote_download_file_name_options_with_http_info(self, node_code, file_name, **kwargs):  # noqa: E501
        """layout_node_code_footnote_download_file_name_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.layout_node_code_footnote_download_file_name_options_with_http_info(node_code, file_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_code: Node Code - Database ID, Topic ID, Section ID or Table ID (required)
        :param str file_name: Resource file name (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_code', 'file_name', 'accept_language', 'lang']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method layout_node_code_footnote_download_file_name_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'node_code' is set
        if self.api_client.client_side_validation and ('node_code' not in params or
                                                       params['node_code'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `node_code` when calling `layout_node_code_footnote_download_file_name_options`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if self.api_client.client_side_validation and ('file_name' not in params or
                                                       params['file_name'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `file_name` when calling `layout_node_code_footnote_download_file_name_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_code' in params:
            path_params['node_code'] = params['node_code']  # noqa: E501
        if 'file_name' in params:
            path_params['file_name'] = params['file_name']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/layout/{node_code}/footnote/download/{file_name}', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def layout_node_code_footnote_download_options(self, node_code, **kwargs):  # noqa: E501
        """layout_node_code_footnote_download_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.layout_node_code_footnote_download_options(node_code, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_code: Node Code - Database ID, Topic ID, Section ID or Table ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.layout_node_code_footnote_download_options_with_http_info(node_code, **kwargs)  # noqa: E501
        else:
            (data) = self.layout_node_code_footnote_download_options_with_http_info(node_code, **kwargs)  # noqa: E501
            return data

    def layout_node_code_footnote_download_options_with_http_info(self, node_code, **kwargs):  # noqa: E501
        """layout_node_code_footnote_download_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.layout_node_code_footnote_download_options_with_http_info(node_code, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_code: Node Code - Database ID, Topic ID, Section ID or Table ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_code', 'accept_language', 'lang']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method layout_node_code_footnote_download_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'node_code' is set
        if self.api_client.client_side_validation and ('node_code' not in params or
                                                       params['node_code'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `node_code` when calling `layout_node_code_footnote_download_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_code' in params:
            path_params['node_code'] = params['node_code']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/layout/{node_code}/footnote/download', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def layout_node_code_footnote_options(self, node_code, **kwargs):  # noqa: E501
        """layout_node_code_footnote_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.layout_node_code_footnote_options(node_code, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_code: Node Code - Database ID, Topic ID, Section ID or Table ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.layout_node_code_footnote_options_with_http_info(node_code, **kwargs)  # noqa: E501
        else:
            (data) = self.layout_node_code_footnote_options_with_http_info(node_code, **kwargs)  # noqa: E501
            return data

    def layout_node_code_footnote_options_with_http_info(self, node_code, **kwargs):  # noqa: E501
        """layout_node_code_footnote_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.layout_node_code_footnote_options_with_http_info(node_code, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_code: Node Code - Database ID, Topic ID, Section ID or Table ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_code', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method layout_node_code_footnote_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'node_code' is set
        if self.api_client.client_side_validation and ('node_code' not in params or
                                                       params['node_code'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `node_code` when calling `layout_node_code_footnote_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_code' in params:
            path_params['node_code'] = params['node_code']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/layout/{node_code}/footnote', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def layout_sections_id_options(self, id, **kwargs):  # noqa: E501
        """layout_sections_id_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.layout_sections_id_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Node ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str keyword: Search term. One or more keywords. May contain special words further controlling the search results. Keyword search tips: `Retail Sales` - Show series with both keywords while the sequence of keywords is irrelevant. Equivalent to search Sales Retail `Retail AND Sales` - Show results: series with terms of Retail AND Sales, regardless of the sequence. E. g. Retail Sales, Automobile Sales Retail `Retail;Sales` - Show series with either keyword and series with both keywords while the sequence of keywords is irrelevant, equivalent to search: Sales;Retail `Retail OR Sales` - Show results: series with terms of Retail OR Sales, regardless of the sequence. E. g. Retail Sales, Retail Trade, Sales Price, Motor Vehicle Sales `Retail NOT Sales` - Narrow a search by excluding specific terms while the sequence of keywords is relevant. Show results: series with terms that include Retail, but NOT Sales. E. g. Retail Trade, Retail Price, Retail Bank `Retail Sales NOT (Hong Kong)` - Narrow a search by excluding a set of words in parentheses while the sequence of keywords in parentheses is irrelevant, equivalent to search: Retail Sales NOT (Hong Kong). Show results: series with terms that include Retail Sales, but NOT Hong Kong, such as Retail Sales YoY: China, Retail Sales YoY: United States
        :param bool strict_keyword_search: When true, will make a strict keywords search instead of fuzzy search.
        :param list[str] frequency: Frequency filter. One or more comma separated frequency code values. D - Daily W - Weekly M - Monthly Q - Quarterly H - Semi-annual Y - Annual Z - Quinquennially T - Decadal
        :param list[str] country: **DEPRECATED. Please use `geo` parameter.** Country filter. One or more comma separated country code values. See related Dictionary function to get the full list of accepted countries.
        :param list[str] source: Source filter. One or more comma separated source code values. See related Dictionary function to get the full list of accepted sources.
        :param list[str] unit: Unit filter. One or more comma separated unit code values. See related Dictionary function to get the full list of accepted units.
        :param list[str] indicator: Indicator filter. One or more comma separated indicator code values. See related Dictionary function to get full list of accepted indicators. The use the new indicators ids is recommended because the old ones are deprecated and going to be removed in the near future!
        :param list[str] region: Region filter. One or more comma separated region code values. See related Dictionary function to get the full list of accepted regions.
        :param bool subscribed_only: Show only results for subscribed series when set to `true`. By default show results for all the series found.
        :param bool key_only: Show only 'key' series when set to `true`.
        :param bool new_only: Show only series created less than 1 month ago when set to `true`.
        :param bool name_only: This filter related with the `keyword` filter. If it's `true` keyword search will be searched only in series name instead of all series attributes.
        :param date start_date_before: Will return series with first observation before `start_date_before`
        :param date end_date_after: Will return series with last observation after `end_date_after`
        :param date created_after: Will return entries created after `created_after` date
        :param date updated_after: Will return series last time updated after `updated_after` date and time
        :param date timepoints_updated_after:  Will return series containing timepoints' last time updated after updated_after date and time
        :param list[str] geo: Geo filter. One or more comma separated geo id values. See related Dictionary function to get the full list of accepted geo ids.
        :param list[str] status: Status filter. One or more comma separated status code values. When not explicitly set, defaults to T.  T - Active C - Discontinued B - Rebased D - On-Demand
        :param list[str] filter_id: Filter ID used to define a subset of data over which the search will be executed. When combined with additional search criterion, the result will be an intesection of both.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.layout_sections_id_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.layout_sections_id_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def layout_sections_id_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """layout_sections_id_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.layout_sections_id_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Node ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str keyword: Search term. One or more keywords. May contain special words further controlling the search results. Keyword search tips: `Retail Sales` - Show series with both keywords while the sequence of keywords is irrelevant. Equivalent to search Sales Retail `Retail AND Sales` - Show results: series with terms of Retail AND Sales, regardless of the sequence. E. g. Retail Sales, Automobile Sales Retail `Retail;Sales` - Show series with either keyword and series with both keywords while the sequence of keywords is irrelevant, equivalent to search: Sales;Retail `Retail OR Sales` - Show results: series with terms of Retail OR Sales, regardless of the sequence. E. g. Retail Sales, Retail Trade, Sales Price, Motor Vehicle Sales `Retail NOT Sales` - Narrow a search by excluding specific terms while the sequence of keywords is relevant. Show results: series with terms that include Retail, but NOT Sales. E. g. Retail Trade, Retail Price, Retail Bank `Retail Sales NOT (Hong Kong)` - Narrow a search by excluding a set of words in parentheses while the sequence of keywords in parentheses is irrelevant, equivalent to search: Retail Sales NOT (Hong Kong). Show results: series with terms that include Retail Sales, but NOT Hong Kong, such as Retail Sales YoY: China, Retail Sales YoY: United States
        :param bool strict_keyword_search: When true, will make a strict keywords search instead of fuzzy search.
        :param list[str] frequency: Frequency filter. One or more comma separated frequency code values. D - Daily W - Weekly M - Monthly Q - Quarterly H - Semi-annual Y - Annual Z - Quinquennially T - Decadal
        :param list[str] country: **DEPRECATED. Please use `geo` parameter.** Country filter. One or more comma separated country code values. See related Dictionary function to get the full list of accepted countries.
        :param list[str] source: Source filter. One or more comma separated source code values. See related Dictionary function to get the full list of accepted sources.
        :param list[str] unit: Unit filter. One or more comma separated unit code values. See related Dictionary function to get the full list of accepted units.
        :param list[str] indicator: Indicator filter. One or more comma separated indicator code values. See related Dictionary function to get full list of accepted indicators. The use the new indicators ids is recommended because the old ones are deprecated and going to be removed in the near future!
        :param list[str] region: Region filter. One or more comma separated region code values. See related Dictionary function to get the full list of accepted regions.
        :param bool subscribed_only: Show only results for subscribed series when set to `true`. By default show results for all the series found.
        :param bool key_only: Show only 'key' series when set to `true`.
        :param bool new_only: Show only series created less than 1 month ago when set to `true`.
        :param bool name_only: This filter related with the `keyword` filter. If it's `true` keyword search will be searched only in series name instead of all series attributes.
        :param date start_date_before: Will return series with first observation before `start_date_before`
        :param date end_date_after: Will return series with last observation after `end_date_after`
        :param date created_after: Will return entries created after `created_after` date
        :param date updated_after: Will return series last time updated after `updated_after` date and time
        :param date timepoints_updated_after:  Will return series containing timepoints' last time updated after updated_after date and time
        :param list[str] geo: Geo filter. One or more comma separated geo id values. See related Dictionary function to get the full list of accepted geo ids.
        :param list[str] status: Status filter. One or more comma separated status code values. When not explicitly set, defaults to T.  T - Active C - Discontinued B - Rebased D - On-Demand
        :param list[str] filter_id: Filter ID used to define a subset of data over which the search will be executed. When combined with additional search criterion, the result will be an intesection of both.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'keyword', 'strict_keyword_search', 'frequency', 'country', 'source', 'unit', 'indicator', 'region', 'subscribed_only', 'key_only', 'new_only', 'name_only', 'start_date_before', 'end_date_after', 'created_after', 'updated_after', 'timepoints_updated_after', 'geo', 'status', 'filter_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method layout_sections_id_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `layout_sections_id_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'keyword' in params:
            query_params.append(('keyword', params['keyword']))  # noqa: E501
        if 'strict_keyword_search' in params:
            query_params.append(('strict_keyword_search', params['strict_keyword_search']))  # noqa: E501
        if 'frequency' in params:
            query_params.append(('frequency', params['frequency']))  # noqa: E501
            collection_formats['frequency'] = 'csv'  # noqa: E501
        if 'country' in params:
            query_params.append(('country', params['country']))  # noqa: E501
            collection_formats['country'] = 'csv'  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
            collection_formats['source'] = 'csv'  # noqa: E501
        if 'unit' in params:
            query_params.append(('unit', params['unit']))  # noqa: E501
            collection_formats['unit'] = 'csv'  # noqa: E501
        if 'indicator' in params:
            query_params.append(('indicator', params['indicator']))  # noqa: E501
            collection_formats['indicator'] = 'csv'  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
            collection_formats['region'] = 'csv'  # noqa: E501
        if 'subscribed_only' in params:
            query_params.append(('subscribed_only', params['subscribed_only']))  # noqa: E501
        if 'key_only' in params:
            query_params.append(('key_only', params['key_only']))  # noqa: E501
        if 'new_only' in params:
            query_params.append(('new_only', params['new_only']))  # noqa: E501
        if 'name_only' in params:
            query_params.append(('name_only', params['name_only']))  # noqa: E501
        if 'start_date_before' in params:
            query_params.append(('start_date_before', params['start_date_before']))  # noqa: E501
        if 'end_date_after' in params:
            query_params.append(('end_date_after', params['end_date_after']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('created_after', params['created_after']))  # noqa: E501
        if 'updated_after' in params:
            query_params.append(('updated_after', params['updated_after']))  # noqa: E501
        if 'timepoints_updated_after' in params:
            query_params.append(('timepoints_updated_after', params['timepoints_updated_after']))  # noqa: E501
        if 'geo' in params:
            query_params.append(('geo', params['geo']))  # noqa: E501
            collection_formats['geo'] = 'csv'  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
            collection_formats['status'] = 'csv'  # noqa: E501
        if 'filter_id' in params:
            query_params.append(('filter_id', params['filter_id']))  # noqa: E501
            collection_formats['filter_id'] = 'csv'  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/layout/sections/{id}', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def layout_sections_id_tables_options(self, id, **kwargs):  # noqa: E501
        """layout_sections_id_tables_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.layout_sections_id_tables_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Section ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str keyword: Search term. One or more keywords. May contain special words further controlling the search results. Keyword search tips: `Retail Sales` - Show series with both keywords while the sequence of keywords is irrelevant. Equivalent to search Sales Retail `Retail AND Sales` - Show results: series with terms of Retail AND Sales, regardless of the sequence. E. g. Retail Sales, Automobile Sales Retail `Retail;Sales` - Show series with either keyword and series with both keywords while the sequence of keywords is irrelevant, equivalent to search: Sales;Retail `Retail OR Sales` - Show results: series with terms of Retail OR Sales, regardless of the sequence. E. g. Retail Sales, Retail Trade, Sales Price, Motor Vehicle Sales `Retail NOT Sales` - Narrow a search by excluding specific terms while the sequence of keywords is relevant. Show results: series with terms that include Retail, but NOT Sales. E. g. Retail Trade, Retail Price, Retail Bank `Retail Sales NOT (Hong Kong)` - Narrow a search by excluding a set of words in parentheses while the sequence of keywords in parentheses is irrelevant, equivalent to search: Retail Sales NOT (Hong Kong). Show results: series with terms that include Retail Sales, but NOT Hong Kong, such as Retail Sales YoY: China, Retail Sales YoY: United States
        :param bool strict_keyword_search: When true, will make a strict keywords search instead of fuzzy search.
        :param list[str] frequency: Frequency filter. One or more comma separated frequency code values. D - Daily W - Weekly M - Monthly Q - Quarterly H - Semi-annual Y - Annual Z - Quinquennially T - Decadal
        :param list[str] country: **DEPRECATED. Please use `geo` parameter.** Country filter. One or more comma separated country code values. See related Dictionary function to get the full list of accepted countries.
        :param list[str] source: Source filter. One or more comma separated source code values. See related Dictionary function to get the full list of accepted sources.
        :param list[str] unit: Unit filter. One or more comma separated unit code values. See related Dictionary function to get the full list of accepted units.
        :param list[str] indicator: Indicator filter. One or more comma separated indicator code values. See related Dictionary function to get full list of accepted indicators. The use the new indicators ids is recommended because the old ones are deprecated and going to be removed in the near future!
        :param list[str] region: Region filter. One or more comma separated region code values. See related Dictionary function to get the full list of accepted regions.
        :param bool subscribed_only: Show only results for subscribed series when set to `true`. By default show results for all the series found.
        :param bool key_only: Show only 'key' series when set to `true`.
        :param bool new_only: Show only series created less than 1 month ago when set to `true`.
        :param bool name_only: This filter related with the `keyword` filter. If it's `true` keyword search will be searched only in series name instead of all series attributes.
        :param date start_date_before: Will return series with first observation before `start_date_before`
        :param date end_date_after: Will return series with last observation after `end_date_after`
        :param date created_after: Will return entries created after `created_after` date
        :param date updated_after: Will return series last time updated after `updated_after` date and time
        :param date timepoints_updated_after:  Will return series containing timepoints' last time updated after updated_after date and time
        :param list[str] geo: Geo filter. One or more comma separated geo id values. See related Dictionary function to get the full list of accepted geo ids.
        :param list[str] status: Status filter. One or more comma separated status code values. When not explicitly set, defaults to T.  T - Active C - Discontinued B - Rebased D - On-Demand
        :param list[str] filter_id: Filter ID used to define a subset of data over which the search will be executed. When combined with additional search criterion, the result will be an intesection of both.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.layout_sections_id_tables_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.layout_sections_id_tables_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def layout_sections_id_tables_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """layout_sections_id_tables_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.layout_sections_id_tables_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Section ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str keyword: Search term. One or more keywords. May contain special words further controlling the search results. Keyword search tips: `Retail Sales` - Show series with both keywords while the sequence of keywords is irrelevant. Equivalent to search Sales Retail `Retail AND Sales` - Show results: series with terms of Retail AND Sales, regardless of the sequence. E. g. Retail Sales, Automobile Sales Retail `Retail;Sales` - Show series with either keyword and series with both keywords while the sequence of keywords is irrelevant, equivalent to search: Sales;Retail `Retail OR Sales` - Show results: series with terms of Retail OR Sales, regardless of the sequence. E. g. Retail Sales, Retail Trade, Sales Price, Motor Vehicle Sales `Retail NOT Sales` - Narrow a search by excluding specific terms while the sequence of keywords is relevant. Show results: series with terms that include Retail, but NOT Sales. E. g. Retail Trade, Retail Price, Retail Bank `Retail Sales NOT (Hong Kong)` - Narrow a search by excluding a set of words in parentheses while the sequence of keywords in parentheses is irrelevant, equivalent to search: Retail Sales NOT (Hong Kong). Show results: series with terms that include Retail Sales, but NOT Hong Kong, such as Retail Sales YoY: China, Retail Sales YoY: United States
        :param bool strict_keyword_search: When true, will make a strict keywords search instead of fuzzy search.
        :param list[str] frequency: Frequency filter. One or more comma separated frequency code values. D - Daily W - Weekly M - Monthly Q - Quarterly H - Semi-annual Y - Annual Z - Quinquennially T - Decadal
        :param list[str] country: **DEPRECATED. Please use `geo` parameter.** Country filter. One or more comma separated country code values. See related Dictionary function to get the full list of accepted countries.
        :param list[str] source: Source filter. One or more comma separated source code values. See related Dictionary function to get the full list of accepted sources.
        :param list[str] unit: Unit filter. One or more comma separated unit code values. See related Dictionary function to get the full list of accepted units.
        :param list[str] indicator: Indicator filter. One or more comma separated indicator code values. See related Dictionary function to get full list of accepted indicators. The use the new indicators ids is recommended because the old ones are deprecated and going to be removed in the near future!
        :param list[str] region: Region filter. One or more comma separated region code values. See related Dictionary function to get the full list of accepted regions.
        :param bool subscribed_only: Show only results for subscribed series when set to `true`. By default show results for all the series found.
        :param bool key_only: Show only 'key' series when set to `true`.
        :param bool new_only: Show only series created less than 1 month ago when set to `true`.
        :param bool name_only: This filter related with the `keyword` filter. If it's `true` keyword search will be searched only in series name instead of all series attributes.
        :param date start_date_before: Will return series with first observation before `start_date_before`
        :param date end_date_after: Will return series with last observation after `end_date_after`
        :param date created_after: Will return entries created after `created_after` date
        :param date updated_after: Will return series last time updated after `updated_after` date and time
        :param date timepoints_updated_after:  Will return series containing timepoints' last time updated after updated_after date and time
        :param list[str] geo: Geo filter. One or more comma separated geo id values. See related Dictionary function to get the full list of accepted geo ids.
        :param list[str] status: Status filter. One or more comma separated status code values. When not explicitly set, defaults to T.  T - Active C - Discontinued B - Rebased D - On-Demand
        :param list[str] filter_id: Filter ID used to define a subset of data over which the search will be executed. When combined with additional search criterion, the result will be an intesection of both.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'keyword', 'strict_keyword_search', 'frequency', 'country', 'source', 'unit', 'indicator', 'region', 'subscribed_only', 'key_only', 'new_only', 'name_only', 'start_date_before', 'end_date_after', 'created_after', 'updated_after', 'timepoints_updated_after', 'geo', 'status', 'filter_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method layout_sections_id_tables_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `layout_sections_id_tables_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'keyword' in params:
            query_params.append(('keyword', params['keyword']))  # noqa: E501
        if 'strict_keyword_search' in params:
            query_params.append(('strict_keyword_search', params['strict_keyword_search']))  # noqa: E501
        if 'frequency' in params:
            query_params.append(('frequency', params['frequency']))  # noqa: E501
            collection_formats['frequency'] = 'csv'  # noqa: E501
        if 'country' in params:
            query_params.append(('country', params['country']))  # noqa: E501
            collection_formats['country'] = 'csv'  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
            collection_formats['source'] = 'csv'  # noqa: E501
        if 'unit' in params:
            query_params.append(('unit', params['unit']))  # noqa: E501
            collection_formats['unit'] = 'csv'  # noqa: E501
        if 'indicator' in params:
            query_params.append(('indicator', params['indicator']))  # noqa: E501
            collection_formats['indicator'] = 'csv'  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
            collection_formats['region'] = 'csv'  # noqa: E501
        if 'subscribed_only' in params:
            query_params.append(('subscribed_only', params['subscribed_only']))  # noqa: E501
        if 'key_only' in params:
            query_params.append(('key_only', params['key_only']))  # noqa: E501
        if 'new_only' in params:
            query_params.append(('new_only', params['new_only']))  # noqa: E501
        if 'name_only' in params:
            query_params.append(('name_only', params['name_only']))  # noqa: E501
        if 'start_date_before' in params:
            query_params.append(('start_date_before', params['start_date_before']))  # noqa: E501
        if 'end_date_after' in params:
            query_params.append(('end_date_after', params['end_date_after']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('created_after', params['created_after']))  # noqa: E501
        if 'updated_after' in params:
            query_params.append(('updated_after', params['updated_after']))  # noqa: E501
        if 'timepoints_updated_after' in params:
            query_params.append(('timepoints_updated_after', params['timepoints_updated_after']))  # noqa: E501
        if 'geo' in params:
            query_params.append(('geo', params['geo']))  # noqa: E501
            collection_formats['geo'] = 'csv'  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
            collection_formats['status'] = 'csv'  # noqa: E501
        if 'filter_id' in params:
            query_params.append(('filter_id', params['filter_id']))  # noqa: E501
            collection_formats['filter_id'] = 'csv'  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/layout/sections/{id}/tables', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def layout_tables_id_options(self, id, **kwargs):  # noqa: E501
        """layout_tables_id_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.layout_tables_id_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Node ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str keyword: Search term. One or more keywords. May contain special words further controlling the search results. Keyword search tips: `Retail Sales` - Show series with both keywords while the sequence of keywords is irrelevant. Equivalent to search Sales Retail `Retail AND Sales` - Show results: series with terms of Retail AND Sales, regardless of the sequence. E. g. Retail Sales, Automobile Sales Retail `Retail;Sales` - Show series with either keyword and series with both keywords while the sequence of keywords is irrelevant, equivalent to search: Sales;Retail `Retail OR Sales` - Show results: series with terms of Retail OR Sales, regardless of the sequence. E. g. Retail Sales, Retail Trade, Sales Price, Motor Vehicle Sales `Retail NOT Sales` - Narrow a search by excluding specific terms while the sequence of keywords is relevant. Show results: series with terms that include Retail, but NOT Sales. E. g. Retail Trade, Retail Price, Retail Bank `Retail Sales NOT (Hong Kong)` - Narrow a search by excluding a set of words in parentheses while the sequence of keywords in parentheses is irrelevant, equivalent to search: Retail Sales NOT (Hong Kong). Show results: series with terms that include Retail Sales, but NOT Hong Kong, such as Retail Sales YoY: China, Retail Sales YoY: United States
        :param bool strict_keyword_search: When true, will make a strict keywords search instead of fuzzy search.
        :param list[str] frequency: Frequency filter. One or more comma separated frequency code values. D - Daily W - Weekly M - Monthly Q - Quarterly H - Semi-annual Y - Annual Z - Quinquennially T - Decadal
        :param list[str] country: **DEPRECATED. Please use `geo` parameter.** Country filter. One or more comma separated country code values. See related Dictionary function to get the full list of accepted countries.
        :param list[str] source: Source filter. One or more comma separated source code values. See related Dictionary function to get the full list of accepted sources.
        :param list[str] unit: Unit filter. One or more comma separated unit code values. See related Dictionary function to get the full list of accepted units.
        :param list[str] indicator: Indicator filter. One or more comma separated indicator code values. See related Dictionary function to get full list of accepted indicators. The use the new indicators ids is recommended because the old ones are deprecated and going to be removed in the near future!
        :param list[str] region: Region filter. One or more comma separated region code values. See related Dictionary function to get the full list of accepted regions.
        :param bool subscribed_only: Show only results for subscribed series when set to `true`. By default show results for all the series found.
        :param bool key_only: Show only 'key' series when set to `true`.
        :param bool new_only: Show only series created less than 1 month ago when set to `true`.
        :param bool name_only: This filter related with the `keyword` filter. If it's `true` keyword search will be searched only in series name instead of all series attributes.
        :param date start_date_before: Will return series with first observation before `start_date_before`
        :param date end_date_after: Will return series with last observation after `end_date_after`
        :param date created_after: Will return entries created after `created_after` date
        :param date updated_after: Will return series last time updated after `updated_after` date and time
        :param date timepoints_updated_after:  Will return series containing timepoints' last time updated after updated_after date and time
        :param list[str] geo: Geo filter. One or more comma separated geo id values. See related Dictionary function to get the full list of accepted geo ids.
        :param list[str] status: Status filter. One or more comma separated status code values. When not explicitly set, defaults to T.  T - Active C - Discontinued B - Rebased D - On-Demand
        :param list[str] filter_id: Filter ID used to define a subset of data over which the search will be executed. When combined with additional search criterion, the result will be an intesection of both.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.layout_tables_id_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.layout_tables_id_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def layout_tables_id_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """layout_tables_id_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.layout_tables_id_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Node ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str keyword: Search term. One or more keywords. May contain special words further controlling the search results. Keyword search tips: `Retail Sales` - Show series with both keywords while the sequence of keywords is irrelevant. Equivalent to search Sales Retail `Retail AND Sales` - Show results: series with terms of Retail AND Sales, regardless of the sequence. E. g. Retail Sales, Automobile Sales Retail `Retail;Sales` - Show series with either keyword and series with both keywords while the sequence of keywords is irrelevant, equivalent to search: Sales;Retail `Retail OR Sales` - Show results: series with terms of Retail OR Sales, regardless of the sequence. E. g. Retail Sales, Retail Trade, Sales Price, Motor Vehicle Sales `Retail NOT Sales` - Narrow a search by excluding specific terms while the sequence of keywords is relevant. Show results: series with terms that include Retail, but NOT Sales. E. g. Retail Trade, Retail Price, Retail Bank `Retail Sales NOT (Hong Kong)` - Narrow a search by excluding a set of words in parentheses while the sequence of keywords in parentheses is irrelevant, equivalent to search: Retail Sales NOT (Hong Kong). Show results: series with terms that include Retail Sales, but NOT Hong Kong, such as Retail Sales YoY: China, Retail Sales YoY: United States
        :param bool strict_keyword_search: When true, will make a strict keywords search instead of fuzzy search.
        :param list[str] frequency: Frequency filter. One or more comma separated frequency code values. D - Daily W - Weekly M - Monthly Q - Quarterly H - Semi-annual Y - Annual Z - Quinquennially T - Decadal
        :param list[str] country: **DEPRECATED. Please use `geo` parameter.** Country filter. One or more comma separated country code values. See related Dictionary function to get the full list of accepted countries.
        :param list[str] source: Source filter. One or more comma separated source code values. See related Dictionary function to get the full list of accepted sources.
        :param list[str] unit: Unit filter. One or more comma separated unit code values. See related Dictionary function to get the full list of accepted units.
        :param list[str] indicator: Indicator filter. One or more comma separated indicator code values. See related Dictionary function to get full list of accepted indicators. The use the new indicators ids is recommended because the old ones are deprecated and going to be removed in the near future!
        :param list[str] region: Region filter. One or more comma separated region code values. See related Dictionary function to get the full list of accepted regions.
        :param bool subscribed_only: Show only results for subscribed series when set to `true`. By default show results for all the series found.
        :param bool key_only: Show only 'key' series when set to `true`.
        :param bool new_only: Show only series created less than 1 month ago when set to `true`.
        :param bool name_only: This filter related with the `keyword` filter. If it's `true` keyword search will be searched only in series name instead of all series attributes.
        :param date start_date_before: Will return series with first observation before `start_date_before`
        :param date end_date_after: Will return series with last observation after `end_date_after`
        :param date created_after: Will return entries created after `created_after` date
        :param date updated_after: Will return series last time updated after `updated_after` date and time
        :param date timepoints_updated_after:  Will return series containing timepoints' last time updated after updated_after date and time
        :param list[str] geo: Geo filter. One or more comma separated geo id values. See related Dictionary function to get the full list of accepted geo ids.
        :param list[str] status: Status filter. One or more comma separated status code values. When not explicitly set, defaults to T.  T - Active C - Discontinued B - Rebased D - On-Demand
        :param list[str] filter_id: Filter ID used to define a subset of data over which the search will be executed. When combined with additional search criterion, the result will be an intesection of both.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'keyword', 'strict_keyword_search', 'frequency', 'country', 'source', 'unit', 'indicator', 'region', 'subscribed_only', 'key_only', 'new_only', 'name_only', 'start_date_before', 'end_date_after', 'created_after', 'updated_after', 'timepoints_updated_after', 'geo', 'status', 'filter_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method layout_tables_id_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `layout_tables_id_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'keyword' in params:
            query_params.append(('keyword', params['keyword']))  # noqa: E501
        if 'strict_keyword_search' in params:
            query_params.append(('strict_keyword_search', params['strict_keyword_search']))  # noqa: E501
        if 'frequency' in params:
            query_params.append(('frequency', params['frequency']))  # noqa: E501
            collection_formats['frequency'] = 'csv'  # noqa: E501
        if 'country' in params:
            query_params.append(('country', params['country']))  # noqa: E501
            collection_formats['country'] = 'csv'  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
            collection_formats['source'] = 'csv'  # noqa: E501
        if 'unit' in params:
            query_params.append(('unit', params['unit']))  # noqa: E501
            collection_formats['unit'] = 'csv'  # noqa: E501
        if 'indicator' in params:
            query_params.append(('indicator', params['indicator']))  # noqa: E501
            collection_formats['indicator'] = 'csv'  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
            collection_formats['region'] = 'csv'  # noqa: E501
        if 'subscribed_only' in params:
            query_params.append(('subscribed_only', params['subscribed_only']))  # noqa: E501
        if 'key_only' in params:
            query_params.append(('key_only', params['key_only']))  # noqa: E501
        if 'new_only' in params:
            query_params.append(('new_only', params['new_only']))  # noqa: E501
        if 'name_only' in params:
            query_params.append(('name_only', params['name_only']))  # noqa: E501
        if 'start_date_before' in params:
            query_params.append(('start_date_before', params['start_date_before']))  # noqa: E501
        if 'end_date_after' in params:
            query_params.append(('end_date_after', params['end_date_after']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('created_after', params['created_after']))  # noqa: E501
        if 'updated_after' in params:
            query_params.append(('updated_after', params['updated_after']))  # noqa: E501
        if 'timepoints_updated_after' in params:
            query_params.append(('timepoints_updated_after', params['timepoints_updated_after']))  # noqa: E501
        if 'geo' in params:
            query_params.append(('geo', params['geo']))  # noqa: E501
            collection_formats['geo'] = 'csv'  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
            collection_formats['status'] = 'csv'  # noqa: E501
        if 'filter_id' in params:
            query_params.append(('filter_id', params['filter_id']))  # noqa: E501
            collection_formats['filter_id'] = 'csv'  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/layout/tables/{id}', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def layout_tables_id_series_options(self, id, **kwargs):  # noqa: E501
        """layout_tables_id_series_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.layout_tables_id_series_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Table ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str keyword: Search term. One or more keywords. May contain special words further controlling the search results. Keyword search tips: `Retail Sales` - Show series with both keywords while the sequence of keywords is irrelevant. Equivalent to search Sales Retail `Retail AND Sales` - Show results: series with terms of Retail AND Sales, regardless of the sequence. E. g. Retail Sales, Automobile Sales Retail `Retail;Sales` - Show series with either keyword and series with both keywords while the sequence of keywords is irrelevant, equivalent to search: Sales;Retail `Retail OR Sales` - Show results: series with terms of Retail OR Sales, regardless of the sequence. E. g. Retail Sales, Retail Trade, Sales Price, Motor Vehicle Sales `Retail NOT Sales` - Narrow a search by excluding specific terms while the sequence of keywords is relevant. Show results: series with terms that include Retail, but NOT Sales. E. g. Retail Trade, Retail Price, Retail Bank `Retail Sales NOT (Hong Kong)` - Narrow a search by excluding a set of words in parentheses while the sequence of keywords in parentheses is irrelevant, equivalent to search: Retail Sales NOT (Hong Kong). Show results: series with terms that include Retail Sales, but NOT Hong Kong, such as Retail Sales YoY: China, Retail Sales YoY: United States
        :param bool strict_keyword_search: When true, will make a strict keywords search instead of fuzzy search.
        :param list[str] frequency: Frequency filter. One or more comma separated frequency code values. D - Daily W - Weekly M - Monthly Q - Quarterly H - Semi-annual Y - Annual Z - Quinquennially T - Decadal
        :param list[str] country: **DEPRECATED. Please use `geo` parameter.** Country filter. One or more comma separated country code values. See related Dictionary function to get the full list of accepted countries.
        :param list[str] source: Source filter. One or more comma separated source code values. See related Dictionary function to get the full list of accepted sources.
        :param list[str] unit: Unit filter. One or more comma separated unit code values. See related Dictionary function to get the full list of accepted units.
        :param list[str] indicator: Indicator filter. One or more comma separated indicator code values. See related Dictionary function to get full list of accepted indicators. The use the new indicators ids is recommended because the old ones are deprecated and going to be removed in the near future!
        :param list[str] region: Region filter. One or more comma separated region code values. See related Dictionary function to get the full list of accepted regions.
        :param bool subscribed_only: Show only results for subscribed series when set to `true`. By default show results for all the series found.
        :param bool key_only: Show only 'key' series when set to `true`.
        :param bool new_only: Show only series created less than 1 month ago when set to `true`.
        :param bool name_only: This filter related with the `keyword` filter. If it's `true` keyword search will be searched only in series name instead of all series attributes.
        :param date start_date_before: Will return series with first observation before `start_date_before`
        :param date end_date_after: Will return series with last observation after `end_date_after`
        :param date created_after: Will return entries created after `created_after` date
        :param date updated_after: Will return series last time updated after `updated_after` date and time
        :param date timepoints_updated_after:  Will return series containing timepoints' last time updated after updated_after date and time
        :param list[str] geo: Geo filter. One or more comma separated geo id values. See related Dictionary function to get the full list of accepted geo ids.
        :param list[str] status: Status filter. One or more comma separated status code values. When not explicitly set, defaults to T.  T - Active C - Discontinued B - Rebased D - On-Demand
        :param list[str] filter_id: Filter ID used to define a subset of data over which the search will be executed. When combined with additional search criterion, the result will be an intesection of both.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.layout_tables_id_series_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.layout_tables_id_series_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def layout_tables_id_series_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """layout_tables_id_series_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.layout_tables_id_series_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Table ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str keyword: Search term. One or more keywords. May contain special words further controlling the search results. Keyword search tips: `Retail Sales` - Show series with both keywords while the sequence of keywords is irrelevant. Equivalent to search Sales Retail `Retail AND Sales` - Show results: series with terms of Retail AND Sales, regardless of the sequence. E. g. Retail Sales, Automobile Sales Retail `Retail;Sales` - Show series with either keyword and series with both keywords while the sequence of keywords is irrelevant, equivalent to search: Sales;Retail `Retail OR Sales` - Show results: series with terms of Retail OR Sales, regardless of the sequence. E. g. Retail Sales, Retail Trade, Sales Price, Motor Vehicle Sales `Retail NOT Sales` - Narrow a search by excluding specific terms while the sequence of keywords is relevant. Show results: series with terms that include Retail, but NOT Sales. E. g. Retail Trade, Retail Price, Retail Bank `Retail Sales NOT (Hong Kong)` - Narrow a search by excluding a set of words in parentheses while the sequence of keywords in parentheses is irrelevant, equivalent to search: Retail Sales NOT (Hong Kong). Show results: series with terms that include Retail Sales, but NOT Hong Kong, such as Retail Sales YoY: China, Retail Sales YoY: United States
        :param bool strict_keyword_search: When true, will make a strict keywords search instead of fuzzy search.
        :param list[str] frequency: Frequency filter. One or more comma separated frequency code values. D - Daily W - Weekly M - Monthly Q - Quarterly H - Semi-annual Y - Annual Z - Quinquennially T - Decadal
        :param list[str] country: **DEPRECATED. Please use `geo` parameter.** Country filter. One or more comma separated country code values. See related Dictionary function to get the full list of accepted countries.
        :param list[str] source: Source filter. One or more comma separated source code values. See related Dictionary function to get the full list of accepted sources.
        :param list[str] unit: Unit filter. One or more comma separated unit code values. See related Dictionary function to get the full list of accepted units.
        :param list[str] indicator: Indicator filter. One or more comma separated indicator code values. See related Dictionary function to get full list of accepted indicators. The use the new indicators ids is recommended because the old ones are deprecated and going to be removed in the near future!
        :param list[str] region: Region filter. One or more comma separated region code values. See related Dictionary function to get the full list of accepted regions.
        :param bool subscribed_only: Show only results for subscribed series when set to `true`. By default show results for all the series found.
        :param bool key_only: Show only 'key' series when set to `true`.
        :param bool new_only: Show only series created less than 1 month ago when set to `true`.
        :param bool name_only: This filter related with the `keyword` filter. If it's `true` keyword search will be searched only in series name instead of all series attributes.
        :param date start_date_before: Will return series with first observation before `start_date_before`
        :param date end_date_after: Will return series with last observation after `end_date_after`
        :param date created_after: Will return entries created after `created_after` date
        :param date updated_after: Will return series last time updated after `updated_after` date and time
        :param date timepoints_updated_after:  Will return series containing timepoints' last time updated after updated_after date and time
        :param list[str] geo: Geo filter. One or more comma separated geo id values. See related Dictionary function to get the full list of accepted geo ids.
        :param list[str] status: Status filter. One or more comma separated status code values. When not explicitly set, defaults to T.  T - Active C - Discontinued B - Rebased D - On-Demand
        :param list[str] filter_id: Filter ID used to define a subset of data over which the search will be executed. When combined with additional search criterion, the result will be an intesection of both.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'keyword', 'strict_keyword_search', 'frequency', 'country', 'source', 'unit', 'indicator', 'region', 'subscribed_only', 'key_only', 'new_only', 'name_only', 'start_date_before', 'end_date_after', 'created_after', 'updated_after', 'timepoints_updated_after', 'geo', 'status', 'filter_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method layout_tables_id_series_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `layout_tables_id_series_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'keyword' in params:
            query_params.append(('keyword', params['keyword']))  # noqa: E501
        if 'strict_keyword_search' in params:
            query_params.append(('strict_keyword_search', params['strict_keyword_search']))  # noqa: E501
        if 'frequency' in params:
            query_params.append(('frequency', params['frequency']))  # noqa: E501
            collection_formats['frequency'] = 'csv'  # noqa: E501
        if 'country' in params:
            query_params.append(('country', params['country']))  # noqa: E501
            collection_formats['country'] = 'csv'  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
            collection_formats['source'] = 'csv'  # noqa: E501
        if 'unit' in params:
            query_params.append(('unit', params['unit']))  # noqa: E501
            collection_formats['unit'] = 'csv'  # noqa: E501
        if 'indicator' in params:
            query_params.append(('indicator', params['indicator']))  # noqa: E501
            collection_formats['indicator'] = 'csv'  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
            collection_formats['region'] = 'csv'  # noqa: E501
        if 'subscribed_only' in params:
            query_params.append(('subscribed_only', params['subscribed_only']))  # noqa: E501
        if 'key_only' in params:
            query_params.append(('key_only', params['key_only']))  # noqa: E501
        if 'new_only' in params:
            query_params.append(('new_only', params['new_only']))  # noqa: E501
        if 'name_only' in params:
            query_params.append(('name_only', params['name_only']))  # noqa: E501
        if 'start_date_before' in params:
            query_params.append(('start_date_before', params['start_date_before']))  # noqa: E501
        if 'end_date_after' in params:
            query_params.append(('end_date_after', params['end_date_after']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('created_after', params['created_after']))  # noqa: E501
        if 'updated_after' in params:
            query_params.append(('updated_after', params['updated_after']))  # noqa: E501
        if 'timepoints_updated_after' in params:
            query_params.append(('timepoints_updated_after', params['timepoints_updated_after']))  # noqa: E501
        if 'geo' in params:
            query_params.append(('geo', params['geo']))  # noqa: E501
            collection_formats['geo'] = 'csv'  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
            collection_formats['status'] = 'csv'  # noqa: E501
        if 'filter_id' in params:
            query_params.append(('filter_id', params['filter_id']))  # noqa: E501
            collection_formats['filter_id'] = 'csv'  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/layout/tables/{id}/series', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def layout_topics_id_options(self, id, **kwargs):  # noqa: E501
        """layout_topics_id_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.layout_topics_id_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Node ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str keyword: Search term. One or more keywords. May contain special words further controlling the search results. Keyword search tips: `Retail Sales` - Show series with both keywords while the sequence of keywords is irrelevant. Equivalent to search Sales Retail `Retail AND Sales` - Show results: series with terms of Retail AND Sales, regardless of the sequence. E. g. Retail Sales, Automobile Sales Retail `Retail;Sales` - Show series with either keyword and series with both keywords while the sequence of keywords is irrelevant, equivalent to search: Sales;Retail `Retail OR Sales` - Show results: series with terms of Retail OR Sales, regardless of the sequence. E. g. Retail Sales, Retail Trade, Sales Price, Motor Vehicle Sales `Retail NOT Sales` - Narrow a search by excluding specific terms while the sequence of keywords is relevant. Show results: series with terms that include Retail, but NOT Sales. E. g. Retail Trade, Retail Price, Retail Bank `Retail Sales NOT (Hong Kong)` - Narrow a search by excluding a set of words in parentheses while the sequence of keywords in parentheses is irrelevant, equivalent to search: Retail Sales NOT (Hong Kong). Show results: series with terms that include Retail Sales, but NOT Hong Kong, such as Retail Sales YoY: China, Retail Sales YoY: United States
        :param bool strict_keyword_search: When true, will make a strict keywords search instead of fuzzy search.
        :param list[str] frequency: Frequency filter. One or more comma separated frequency code values. D - Daily W - Weekly M - Monthly Q - Quarterly H - Semi-annual Y - Annual Z - Quinquennially T - Decadal
        :param list[str] country: **DEPRECATED. Please use `geo` parameter.** Country filter. One or more comma separated country code values. See related Dictionary function to get the full list of accepted countries.
        :param list[str] source: Source filter. One or more comma separated source code values. See related Dictionary function to get the full list of accepted sources.
        :param list[str] unit: Unit filter. One or more comma separated unit code values. See related Dictionary function to get the full list of accepted units.
        :param list[str] indicator: Indicator filter. One or more comma separated indicator code values. See related Dictionary function to get full list of accepted indicators. The use the new indicators ids is recommended because the old ones are deprecated and going to be removed in the near future!
        :param list[str] region: Region filter. One or more comma separated region code values. See related Dictionary function to get the full list of accepted regions.
        :param bool subscribed_only: Show only results for subscribed series when set to `true`. By default show results for all the series found.
        :param bool key_only: Show only 'key' series when set to `true`.
        :param bool new_only: Show only series created less than 1 month ago when set to `true`.
        :param bool name_only: This filter related with the `keyword` filter. If it's `true` keyword search will be searched only in series name instead of all series attributes.
        :param date start_date_before: Will return series with first observation before `start_date_before`
        :param date end_date_after: Will return series with last observation after `end_date_after`
        :param date created_after: Will return entries created after `created_after` date
        :param date updated_after: Will return series last time updated after `updated_after` date and time
        :param date timepoints_updated_after:  Will return series containing timepoints' last time updated after updated_after date and time
        :param list[str] geo: Geo filter. One or more comma separated geo id values. See related Dictionary function to get the full list of accepted geo ids.
        :param list[str] status: Status filter. One or more comma separated status code values. When not explicitly set, defaults to T.  T - Active C - Discontinued B - Rebased D - On-Demand
        :param list[str] filter_id: Filter ID used to define a subset of data over which the search will be executed. When combined with additional search criterion, the result will be an intesection of both.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.layout_topics_id_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.layout_topics_id_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def layout_topics_id_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """layout_topics_id_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.layout_topics_id_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Node ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str keyword: Search term. One or more keywords. May contain special words further controlling the search results. Keyword search tips: `Retail Sales` - Show series with both keywords while the sequence of keywords is irrelevant. Equivalent to search Sales Retail `Retail AND Sales` - Show results: series with terms of Retail AND Sales, regardless of the sequence. E. g. Retail Sales, Automobile Sales Retail `Retail;Sales` - Show series with either keyword and series with both keywords while the sequence of keywords is irrelevant, equivalent to search: Sales;Retail `Retail OR Sales` - Show results: series with terms of Retail OR Sales, regardless of the sequence. E. g. Retail Sales, Retail Trade, Sales Price, Motor Vehicle Sales `Retail NOT Sales` - Narrow a search by excluding specific terms while the sequence of keywords is relevant. Show results: series with terms that include Retail, but NOT Sales. E. g. Retail Trade, Retail Price, Retail Bank `Retail Sales NOT (Hong Kong)` - Narrow a search by excluding a set of words in parentheses while the sequence of keywords in parentheses is irrelevant, equivalent to search: Retail Sales NOT (Hong Kong). Show results: series with terms that include Retail Sales, but NOT Hong Kong, such as Retail Sales YoY: China, Retail Sales YoY: United States
        :param bool strict_keyword_search: When true, will make a strict keywords search instead of fuzzy search.
        :param list[str] frequency: Frequency filter. One or more comma separated frequency code values. D - Daily W - Weekly M - Monthly Q - Quarterly H - Semi-annual Y - Annual Z - Quinquennially T - Decadal
        :param list[str] country: **DEPRECATED. Please use `geo` parameter.** Country filter. One or more comma separated country code values. See related Dictionary function to get the full list of accepted countries.
        :param list[str] source: Source filter. One or more comma separated source code values. See related Dictionary function to get the full list of accepted sources.
        :param list[str] unit: Unit filter. One or more comma separated unit code values. See related Dictionary function to get the full list of accepted units.
        :param list[str] indicator: Indicator filter. One or more comma separated indicator code values. See related Dictionary function to get full list of accepted indicators. The use the new indicators ids is recommended because the old ones are deprecated and going to be removed in the near future!
        :param list[str] region: Region filter. One or more comma separated region code values. See related Dictionary function to get the full list of accepted regions.
        :param bool subscribed_only: Show only results for subscribed series when set to `true`. By default show results for all the series found.
        :param bool key_only: Show only 'key' series when set to `true`.
        :param bool new_only: Show only series created less than 1 month ago when set to `true`.
        :param bool name_only: This filter related with the `keyword` filter. If it's `true` keyword search will be searched only in series name instead of all series attributes.
        :param date start_date_before: Will return series with first observation before `start_date_before`
        :param date end_date_after: Will return series with last observation after `end_date_after`
        :param date created_after: Will return entries created after `created_after` date
        :param date updated_after: Will return series last time updated after `updated_after` date and time
        :param date timepoints_updated_after:  Will return series containing timepoints' last time updated after updated_after date and time
        :param list[str] geo: Geo filter. One or more comma separated geo id values. See related Dictionary function to get the full list of accepted geo ids.
        :param list[str] status: Status filter. One or more comma separated status code values. When not explicitly set, defaults to T.  T - Active C - Discontinued B - Rebased D - On-Demand
        :param list[str] filter_id: Filter ID used to define a subset of data over which the search will be executed. When combined with additional search criterion, the result will be an intesection of both.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'keyword', 'strict_keyword_search', 'frequency', 'country', 'source', 'unit', 'indicator', 'region', 'subscribed_only', 'key_only', 'new_only', 'name_only', 'start_date_before', 'end_date_after', 'created_after', 'updated_after', 'timepoints_updated_after', 'geo', 'status', 'filter_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method layout_topics_id_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `layout_topics_id_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'keyword' in params:
            query_params.append(('keyword', params['keyword']))  # noqa: E501
        if 'strict_keyword_search' in params:
            query_params.append(('strict_keyword_search', params['strict_keyword_search']))  # noqa: E501
        if 'frequency' in params:
            query_params.append(('frequency', params['frequency']))  # noqa: E501
            collection_formats['frequency'] = 'csv'  # noqa: E501
        if 'country' in params:
            query_params.append(('country', params['country']))  # noqa: E501
            collection_formats['country'] = 'csv'  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
            collection_formats['source'] = 'csv'  # noqa: E501
        if 'unit' in params:
            query_params.append(('unit', params['unit']))  # noqa: E501
            collection_formats['unit'] = 'csv'  # noqa: E501
        if 'indicator' in params:
            query_params.append(('indicator', params['indicator']))  # noqa: E501
            collection_formats['indicator'] = 'csv'  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
            collection_formats['region'] = 'csv'  # noqa: E501
        if 'subscribed_only' in params:
            query_params.append(('subscribed_only', params['subscribed_only']))  # noqa: E501
        if 'key_only' in params:
            query_params.append(('key_only', params['key_only']))  # noqa: E501
        if 'new_only' in params:
            query_params.append(('new_only', params['new_only']))  # noqa: E501
        if 'name_only' in params:
            query_params.append(('name_only', params['name_only']))  # noqa: E501
        if 'start_date_before' in params:
            query_params.append(('start_date_before', params['start_date_before']))  # noqa: E501
        if 'end_date_after' in params:
            query_params.append(('end_date_after', params['end_date_after']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('created_after', params['created_after']))  # noqa: E501
        if 'updated_after' in params:
            query_params.append(('updated_after', params['updated_after']))  # noqa: E501
        if 'timepoints_updated_after' in params:
            query_params.append(('timepoints_updated_after', params['timepoints_updated_after']))  # noqa: E501
        if 'geo' in params:
            query_params.append(('geo', params['geo']))  # noqa: E501
            collection_formats['geo'] = 'csv'  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
            collection_formats['status'] = 'csv'  # noqa: E501
        if 'filter_id' in params:
            query_params.append(('filter_id', params['filter_id']))  # noqa: E501
            collection_formats['filter_id'] = 'csv'  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/layout/topics/{id}', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def layout_topics_id_sections_options(self, id, **kwargs):  # noqa: E501
        """layout_topics_id_sections_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.layout_topics_id_sections_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Topic ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str keyword: Search term. One or more keywords. May contain special words further controlling the search results. Keyword search tips: `Retail Sales` - Show series with both keywords while the sequence of keywords is irrelevant. Equivalent to search Sales Retail `Retail AND Sales` - Show results: series with terms of Retail AND Sales, regardless of the sequence. E. g. Retail Sales, Automobile Sales Retail `Retail;Sales` - Show series with either keyword and series with both keywords while the sequence of keywords is irrelevant, equivalent to search: Sales;Retail `Retail OR Sales` - Show results: series with terms of Retail OR Sales, regardless of the sequence. E. g. Retail Sales, Retail Trade, Sales Price, Motor Vehicle Sales `Retail NOT Sales` - Narrow a search by excluding specific terms while the sequence of keywords is relevant. Show results: series with terms that include Retail, but NOT Sales. E. g. Retail Trade, Retail Price, Retail Bank `Retail Sales NOT (Hong Kong)` - Narrow a search by excluding a set of words in parentheses while the sequence of keywords in parentheses is irrelevant, equivalent to search: Retail Sales NOT (Hong Kong). Show results: series with terms that include Retail Sales, but NOT Hong Kong, such as Retail Sales YoY: China, Retail Sales YoY: United States
        :param bool strict_keyword_search: When true, will make a strict keywords search instead of fuzzy search.
        :param list[str] frequency: Frequency filter. One or more comma separated frequency code values. D - Daily W - Weekly M - Monthly Q - Quarterly H - Semi-annual Y - Annual Z - Quinquennially T - Decadal
        :param list[str] country: **DEPRECATED. Please use `geo` parameter.** Country filter. One or more comma separated country code values. See related Dictionary function to get the full list of accepted countries.
        :param list[str] source: Source filter. One or more comma separated source code values. See related Dictionary function to get the full list of accepted sources.
        :param list[str] unit: Unit filter. One or more comma separated unit code values. See related Dictionary function to get the full list of accepted units.
        :param list[str] indicator: Indicator filter. One or more comma separated indicator code values. See related Dictionary function to get full list of accepted indicators. The use the new indicators ids is recommended because the old ones are deprecated and going to be removed in the near future!
        :param list[str] region: Region filter. One or more comma separated region code values. See related Dictionary function to get the full list of accepted regions.
        :param bool subscribed_only: Show only results for subscribed series when set to `true`. By default show results for all the series found.
        :param bool key_only: Show only 'key' series when set to `true`.
        :param bool new_only: Show only series created less than 1 month ago when set to `true`.
        :param bool name_only: This filter related with the `keyword` filter. If it's `true` keyword search will be searched only in series name instead of all series attributes.
        :param date start_date_before: Will return series with first observation before `start_date_before`
        :param date end_date_after: Will return series with last observation after `end_date_after`
        :param date created_after: Will return entries created after `created_after` date
        :param date updated_after: Will return series last time updated after `updated_after` date and time
        :param date timepoints_updated_after:  Will return series containing timepoints' last time updated after updated_after date and time
        :param list[str] geo: Geo filter. One or more comma separated geo id values. See related Dictionary function to get the full list of accepted geo ids.
        :param list[str] status: Status filter. One or more comma separated status code values. When not explicitly set, defaults to T.  T - Active C - Discontinued B - Rebased D - On-Demand
        :param list[str] filter_id: Filter ID used to define a subset of data over which the search will be executed. When combined with additional search criterion, the result will be an intesection of both.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.layout_topics_id_sections_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.layout_topics_id_sections_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def layout_topics_id_sections_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """layout_topics_id_sections_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.layout_topics_id_sections_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Topic ID (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str keyword: Search term. One or more keywords. May contain special words further controlling the search results. Keyword search tips: `Retail Sales` - Show series with both keywords while the sequence of keywords is irrelevant. Equivalent to search Sales Retail `Retail AND Sales` - Show results: series with terms of Retail AND Sales, regardless of the sequence. E. g. Retail Sales, Automobile Sales Retail `Retail;Sales` - Show series with either keyword and series with both keywords while the sequence of keywords is irrelevant, equivalent to search: Sales;Retail `Retail OR Sales` - Show results: series with terms of Retail OR Sales, regardless of the sequence. E. g. Retail Sales, Retail Trade, Sales Price, Motor Vehicle Sales `Retail NOT Sales` - Narrow a search by excluding specific terms while the sequence of keywords is relevant. Show results: series with terms that include Retail, but NOT Sales. E. g. Retail Trade, Retail Price, Retail Bank `Retail Sales NOT (Hong Kong)` - Narrow a search by excluding a set of words in parentheses while the sequence of keywords in parentheses is irrelevant, equivalent to search: Retail Sales NOT (Hong Kong). Show results: series with terms that include Retail Sales, but NOT Hong Kong, such as Retail Sales YoY: China, Retail Sales YoY: United States
        :param bool strict_keyword_search: When true, will make a strict keywords search instead of fuzzy search.
        :param list[str] frequency: Frequency filter. One or more comma separated frequency code values. D - Daily W - Weekly M - Monthly Q - Quarterly H - Semi-annual Y - Annual Z - Quinquennially T - Decadal
        :param list[str] country: **DEPRECATED. Please use `geo` parameter.** Country filter. One or more comma separated country code values. See related Dictionary function to get the full list of accepted countries.
        :param list[str] source: Source filter. One or more comma separated source code values. See related Dictionary function to get the full list of accepted sources.
        :param list[str] unit: Unit filter. One or more comma separated unit code values. See related Dictionary function to get the full list of accepted units.
        :param list[str] indicator: Indicator filter. One or more comma separated indicator code values. See related Dictionary function to get full list of accepted indicators. The use the new indicators ids is recommended because the old ones are deprecated and going to be removed in the near future!
        :param list[str] region: Region filter. One or more comma separated region code values. See related Dictionary function to get the full list of accepted regions.
        :param bool subscribed_only: Show only results for subscribed series when set to `true`. By default show results for all the series found.
        :param bool key_only: Show only 'key' series when set to `true`.
        :param bool new_only: Show only series created less than 1 month ago when set to `true`.
        :param bool name_only: This filter related with the `keyword` filter. If it's `true` keyword search will be searched only in series name instead of all series attributes.
        :param date start_date_before: Will return series with first observation before `start_date_before`
        :param date end_date_after: Will return series with last observation after `end_date_after`
        :param date created_after: Will return entries created after `created_after` date
        :param date updated_after: Will return series last time updated after `updated_after` date and time
        :param date timepoints_updated_after:  Will return series containing timepoints' last time updated after updated_after date and time
        :param list[str] geo: Geo filter. One or more comma separated geo id values. See related Dictionary function to get the full list of accepted geo ids.
        :param list[str] status: Status filter. One or more comma separated status code values. When not explicitly set, defaults to T.  T - Active C - Discontinued B - Rebased D - On-Demand
        :param list[str] filter_id: Filter ID used to define a subset of data over which the search will be executed. When combined with additional search criterion, the result will be an intesection of both.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'keyword', 'strict_keyword_search', 'frequency', 'country', 'source', 'unit', 'indicator', 'region', 'subscribed_only', 'key_only', 'new_only', 'name_only', 'start_date_before', 'end_date_after', 'created_after', 'updated_after', 'timepoints_updated_after', 'geo', 'status', 'filter_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method layout_topics_id_sections_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `layout_topics_id_sections_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'keyword' in params:
            query_params.append(('keyword', params['keyword']))  # noqa: E501
        if 'strict_keyword_search' in params:
            query_params.append(('strict_keyword_search', params['strict_keyword_search']))  # noqa: E501
        if 'frequency' in params:
            query_params.append(('frequency', params['frequency']))  # noqa: E501
            collection_formats['frequency'] = 'csv'  # noqa: E501
        if 'country' in params:
            query_params.append(('country', params['country']))  # noqa: E501
            collection_formats['country'] = 'csv'  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
            collection_formats['source'] = 'csv'  # noqa: E501
        if 'unit' in params:
            query_params.append(('unit', params['unit']))  # noqa: E501
            collection_formats['unit'] = 'csv'  # noqa: E501
        if 'indicator' in params:
            query_params.append(('indicator', params['indicator']))  # noqa: E501
            collection_formats['indicator'] = 'csv'  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
            collection_formats['region'] = 'csv'  # noqa: E501
        if 'subscribed_only' in params:
            query_params.append(('subscribed_only', params['subscribed_only']))  # noqa: E501
        if 'key_only' in params:
            query_params.append(('key_only', params['key_only']))  # noqa: E501
        if 'new_only' in params:
            query_params.append(('new_only', params['new_only']))  # noqa: E501
        if 'name_only' in params:
            query_params.append(('name_only', params['name_only']))  # noqa: E501
        if 'start_date_before' in params:
            query_params.append(('start_date_before', params['start_date_before']))  # noqa: E501
        if 'end_date_after' in params:
            query_params.append(('end_date_after', params['end_date_after']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('created_after', params['created_after']))  # noqa: E501
        if 'updated_after' in params:
            query_params.append(('updated_after', params['updated_after']))  # noqa: E501
        if 'timepoints_updated_after' in params:
            query_params.append(('timepoints_updated_after', params['timepoints_updated_after']))  # noqa: E501
        if 'geo' in params:
            query_params.append(('geo', params['geo']))  # noqa: E501
            collection_formats['geo'] = 'csv'  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
            collection_formats['status'] = 'csv'  # noqa: E501
        if 'filter_id' in params:
            query_params.append(('filter_id', params['filter_id']))  # noqa: E501
            collection_formats['filter_id'] = 'csv'  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/layout/topics/{id}/sections', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def login_options(self, **kwargs):  # noqa: E501
        """login_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.login_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.login_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.login_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def login_options_with_http_info(self, **kwargs):  # noqa: E501
        """login_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.login_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method login_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/login', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def logout_session_options(self, session, **kwargs):  # noqa: E501
        """logout_session_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.logout_session_options(session, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str session: User session (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.logout_session_options_with_http_info(session, **kwargs)  # noqa: E501
        else:
            (data) = self.logout_session_options_with_http_info(session, **kwargs)  # noqa: E501
            return data

    def logout_session_options_with_http_info(self, session, **kwargs):  # noqa: E501
        """logout_session_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.logout_session_options_with_http_info(session, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str session: User session (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['session']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method logout_session_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'session' is set
        if self.api_client.client_side_validation and ('session' not in params or
                                                       params['session'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `session` when calling `logout_session_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session' in params:
            path_params['session'] = params['session']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/logout/{session}', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_code_series_options(self, code, **kwargs):  # noqa: E501
        """releases_code_series_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_code_series_options(code, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str code: Release identifier code for a group of series with the same release schedule. Accepts only one release identifier code. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param float limit: Number of records to return in the range 1 - 100. Default is 100.
        :param float offset: The offset from which the records will be returned. Used to get the next set of records when the limit is reached.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_code_series_options_with_http_info(code, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_code_series_options_with_http_info(code, **kwargs)  # noqa: E501
            return data

    def releases_code_series_options_with_http_info(self, code, **kwargs):  # noqa: E501
        """releases_code_series_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_code_series_options_with_http_info(code, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str code: Release identifier code for a group of series with the same release schedule. Accepts only one release identifier code. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param float limit: Number of records to return in the range 1 - 100. Default is 100.
        :param float offset: The offset from which the records will be returned. Used to get the next set of records when the limit is reached.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['code', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_code_series_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'code' is set
        if self.api_client.client_side_validation and ('code' not in params or
                                                       params['code'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `code` when calling `releases_code_series_options`")  # noqa: E501

        if self.api_client.client_side_validation and ('limit' in params and params['limit'] > 100):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `releases_code_series_options`, must be a value less than or equal to `100`")  # noqa: E501
        if self.api_client.client_side_validation and ('limit' in params and params['limit'] < 1):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `releases_code_series_options`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'code' in params:
            path_params['code'] = params['code']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/releases/{code}/series', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_options(self, **kwargs):  # noqa: E501
        """releases_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param float limit: Number of records to return in the range 1 - 100. Default is 100.
        :param float offset: The offset from which the records will be returned. Used to get the next set of records when the limit is reached.
        :param list[str] layout: **DEPRECATED. Please use `database` parameter.** Database filter. One or more comma separated database code values. Use `/dictionary/databases` to get an up to date list of available databases. WORLD - *World Trend Plus*  WGEM - *Economic Monitor*  WESG - *Environmental, Social and Governance*  WAEM - *ASEAN Economic Monitor*  WFOR - *Forecast*  WCOM - *Commodity Market*  WCOC - *Country Competitiveness*  WAGR - *Aggregates*  WASS - *International Associations*  GLOBAL - *Global Database*  AA - *Asia*  ECA - *Europe and Central Asia*  MEA - *Middle East and Africa*  NSA - *North and South America*  CEICGLBKS - *Global Key Series Database*  PMI - *S&P Global Purchasing Managers' Index*  CEICEPFRLI - *EPFR Macro Flows*  CEICEPFRCF - *EPFR Country Flow*  CEICEPFRCA - *EPFR Country Allocations*  CEICEPFRFF - *EPFR Fund Flow*  CEICGFI - *GFI Fenics Market Data*  CEICMSCI - *MSCI Global Equity Index*  DAILY - *High Frequency Database*  ALT - *Alternative Data*  FMS - *Financial and Monetary Statistics*  HL - *Health*  ASEAN - *ASEAN Premium Database*  APBN - *ASEAN: Brunei*  APKH - *ASEAN: Cambodia*  APLA - *ASEAN: Laos*  APMY - *ASEAN: Malaysia*  APMM - *ASEAN: Myanmar*  APPH - *ASEAN: Philippines*  APSG - *ASEAN: Singapore*  APTH - *ASEAN: Thailand*  APVN - *ASEAN: Vietnam*  BRAZIL - *Brazil Premium Database*  RUSSIA - *Russia Premium Database*  INDIA - *India Premium Database*  INDONESIA - *Indonesia Premium Database*  CN - *China Premium Database*         
        :param list[str] database:  Database filter. One or more comma separated database code values. Use `/dictionary/databases` to get an up to date list of available databases. WORLD - *World Trend Plus*  WGEM - *Economic Monitor*  WESG - *Environmental, Social and Governance*  WAEM - *ASEAN Economic Monitor*  WFOR - *Forecast*  WCOM - *Commodity Market*  WCOC - *Country Competitiveness*  WAGR - *Aggregates*  WASS - *International Associations*  GLOBAL - *Global Database*  AA - *Asia*  ECA - *Europe and Central Asia*  MEA - *Middle East and Africa*  NSA - *North and South America*  CEICGLBKS - *Global Key Series Database*  PMI - *S&P Global Purchasing Managers' Index*  CEICEPFRLI - *EPFR Macro Flows*  CEICEPFRCF - *EPFR Country Flow*  CEICEPFRCA - *EPFR Country Allocations*  CEICEPFRFF - *EPFR Fund Flow*  CEICGFI - *GFI Fenics Market Data*  CEICMSCI - *MSCI Global Equity Index*  DAILY - *High Frequency Database*  ALT - *Alternative Data*  FMS - *Financial and Monetary Statistics*  HL - *Health*  ASEAN - *ASEAN Premium Database*  APBN - *ASEAN: Brunei*  APKH - *ASEAN: Cambodia*  APLA - *ASEAN: Laos*  APMY - *ASEAN: Malaysia*  APMM - *ASEAN: Myanmar*  APPH - *ASEAN: Philippines*  APSG - *ASEAN: Singapore*  APTH - *ASEAN: Thailand*  APVN - *ASEAN: Vietnam*  BRAZIL - *Brazil Premium Database*  RUSSIA - *Russia Premium Database*  INDIA - *India Premium Database*  INDONESIA - *Indonesia Premium Database*  CN - *China Premium Database*         
        :param str keyword: Search term. One or more keywords. May contain special words further controlling the search results. Keyword search tips: `Retail Sales` - Show series with both keywords while the sequence of keywords is irrelevant. Equivalent to search Sales Retail `Retail AND Sales` - Show results: series with terms of Retail AND Sales, regardless of the sequence. E. g. Retail Sales, Automobile Sales Retail `Retail;Sales` - Show series with either keyword and series with both keywords while the sequence of keywords is irrelevant, equivalent to search: Sales;Retail `Retail OR Sales` - Show results: series with terms of Retail OR Sales, regardless of the sequence. E. g. Retail Sales, Retail Trade, Sales Price, Motor Vehicle Sales `Retail NOT Sales` - Narrow a search by excluding specific terms while the sequence of keywords is relevant. Show results: series with terms that include Retail, but NOT Sales. E. g. Retail Trade, Retail Price, Retail Bank `Retail Sales NOT (Hong Kong)` - Narrow a search by excluding a set of words in parentheses while the sequence of keywords in parentheses is irrelevant, equivalent to search: Retail Sales NOT (Hong Kong). Show results: series with terms that include Retail Sales, but NOT Hong Kong, such as Retail Sales YoY: China, Retail Sales YoY: United States
        :param bool strict_keyword_search: When true, will make a strict keywords search instead of fuzzy search.
        :param list[str] frequency: Frequency filter. One or more comma separated frequency code values. D - Daily W - Weekly M - Monthly Q - Quarterly H - Semi-annual Y - Annual Z - Quinquennially T - Decadal
        :param list[str] country: **DEPRECATED. Please use `geo` parameter.** Country filter. One or more comma separated country code values. See related Dictionary function to get the full list of accepted countries.
        :param list[str] source: Source filter. One or more comma separated source code values. See related Dictionary function to get the full list of accepted sources.
        :param list[str] unit: Unit filter. One or more comma separated unit code values. See related Dictionary function to get the full list of accepted units.
        :param list[str] indicator: Indicator filter. One or more comma separated indicator code values. See related Dictionary function to get full list of accepted indicators. The use the new indicators ids is recommended because the old ones are deprecated and going to be removed in the near future!
        :param list[str] region: Region filter. One or more comma separated region code values. See related Dictionary function to get the full list of accepted regions.
        :param bool subscribed_only: Show only results for subscribed series when set to `true`. By default show results for all the series found.
        :param bool key_only: Show only 'key' series when set to `true`.
        :param bool new_only: Show only series created less than 1 month ago when set to `true`.
        :param bool name_only: This filter related with the `keyword` filter. If it's `true` keyword search will be searched only in series name instead of all series attributes.
        :param date start_date_before: Will return series with first observation before `start_date_before`
        :param date end_date_after: Will return series with last observation after `end_date_after`
        :param date created_after: Will return entries created after `created_after` date
        :param date updated_after: Will return series last time updated after `updated_after` date and time
        :param date timepoints_updated_after:  Will return series containing timepoints' last time updated after updated_after date and time
        :param list[str] geo: Geo filter. One or more comma separated geo id values. See related Dictionary function to get the full list of accepted geo ids.
        :param list[str] status: Status filter. One or more comma separated status code values. When not explicitly set, defaults to T.  T - Active C - Discontinued B - Rebased D - On-Demand
        :param list[str] data_source: Data source for series search operation. When CEIC is selected, we search for CEIC series only. When USER-IMPORTED is selected, we search only for user imported series
        :param list[str] series: List of series
        :param bool with_vintage_enabled_only: If it is `true` result will contain ONLY vintage enabled series
        :param bool headline_only: Show only 'headline' series when set to `true`.
        :param list[str] topic: Topic filter. One or more comma separated topic code values.
        :param list[str] section: Section filter. One or more comma separated section code values.
        :param list[str] table: Table filter. One or more comma separated table code values.
        :param list[str] order: Sort order. Default is `relevance`.
        :param list[str] direction: Sort order direction. Default is `asc`. Accepted values: `asc` - ascending `desc` - descending
        :param list[str] filter_id: Filter ID used to define a subset of data over which the search will be executed. When combined with additional search criterion, the result will be an intesection of both.
        :param bool with_replacements_metadata: If it is `true` result will contain replacements metadata not only list of id`s
        :param bool forecast_only: If it is `true` result will only contain series with forecast
        :param bool with_release_only: If it is `true` result will only contain series with released schedule
        :param bool with_replacements_only: If it is `true` result will only contain series with suggestions
        :param bool with_observations_only: If it is `true` result will not contain series without observations
        :param bool with_continuous_only: If set to `true` results will contain only series with available historical extensions
        :param list[str] facet: List of facets to return
        :param date release_date_from: Will return releases with first observation before `release_date_from`
        :param date release_date_to: Will return releases with last observation after `release_date_to`
        :param list[str] release_status: List of release statuses to return
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.releases_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def releases_options_with_http_info(self, **kwargs):  # noqa: E501
        """releases_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param float limit: Number of records to return in the range 1 - 100. Default is 100.
        :param float offset: The offset from which the records will be returned. Used to get the next set of records when the limit is reached.
        :param list[str] layout: **DEPRECATED. Please use `database` parameter.** Database filter. One or more comma separated database code values. Use `/dictionary/databases` to get an up to date list of available databases. WORLD - *World Trend Plus*  WGEM - *Economic Monitor*  WESG - *Environmental, Social and Governance*  WAEM - *ASEAN Economic Monitor*  WFOR - *Forecast*  WCOM - *Commodity Market*  WCOC - *Country Competitiveness*  WAGR - *Aggregates*  WASS - *International Associations*  GLOBAL - *Global Database*  AA - *Asia*  ECA - *Europe and Central Asia*  MEA - *Middle East and Africa*  NSA - *North and South America*  CEICGLBKS - *Global Key Series Database*  PMI - *S&P Global Purchasing Managers' Index*  CEICEPFRLI - *EPFR Macro Flows*  CEICEPFRCF - *EPFR Country Flow*  CEICEPFRCA - *EPFR Country Allocations*  CEICEPFRFF - *EPFR Fund Flow*  CEICGFI - *GFI Fenics Market Data*  CEICMSCI - *MSCI Global Equity Index*  DAILY - *High Frequency Database*  ALT - *Alternative Data*  FMS - *Financial and Monetary Statistics*  HL - *Health*  ASEAN - *ASEAN Premium Database*  APBN - *ASEAN: Brunei*  APKH - *ASEAN: Cambodia*  APLA - *ASEAN: Laos*  APMY - *ASEAN: Malaysia*  APMM - *ASEAN: Myanmar*  APPH - *ASEAN: Philippines*  APSG - *ASEAN: Singapore*  APTH - *ASEAN: Thailand*  APVN - *ASEAN: Vietnam*  BRAZIL - *Brazil Premium Database*  RUSSIA - *Russia Premium Database*  INDIA - *India Premium Database*  INDONESIA - *Indonesia Premium Database*  CN - *China Premium Database*         
        :param list[str] database:  Database filter. One or more comma separated database code values. Use `/dictionary/databases` to get an up to date list of available databases. WORLD - *World Trend Plus*  WGEM - *Economic Monitor*  WESG - *Environmental, Social and Governance*  WAEM - *ASEAN Economic Monitor*  WFOR - *Forecast*  WCOM - *Commodity Market*  WCOC - *Country Competitiveness*  WAGR - *Aggregates*  WASS - *International Associations*  GLOBAL - *Global Database*  AA - *Asia*  ECA - *Europe and Central Asia*  MEA - *Middle East and Africa*  NSA - *North and South America*  CEICGLBKS - *Global Key Series Database*  PMI - *S&P Global Purchasing Managers' Index*  CEICEPFRLI - *EPFR Macro Flows*  CEICEPFRCF - *EPFR Country Flow*  CEICEPFRCA - *EPFR Country Allocations*  CEICEPFRFF - *EPFR Fund Flow*  CEICGFI - *GFI Fenics Market Data*  CEICMSCI - *MSCI Global Equity Index*  DAILY - *High Frequency Database*  ALT - *Alternative Data*  FMS - *Financial and Monetary Statistics*  HL - *Health*  ASEAN - *ASEAN Premium Database*  APBN - *ASEAN: Brunei*  APKH - *ASEAN: Cambodia*  APLA - *ASEAN: Laos*  APMY - *ASEAN: Malaysia*  APMM - *ASEAN: Myanmar*  APPH - *ASEAN: Philippines*  APSG - *ASEAN: Singapore*  APTH - *ASEAN: Thailand*  APVN - *ASEAN: Vietnam*  BRAZIL - *Brazil Premium Database*  RUSSIA - *Russia Premium Database*  INDIA - *India Premium Database*  INDONESIA - *Indonesia Premium Database*  CN - *China Premium Database*         
        :param str keyword: Search term. One or more keywords. May contain special words further controlling the search results. Keyword search tips: `Retail Sales` - Show series with both keywords while the sequence of keywords is irrelevant. Equivalent to search Sales Retail `Retail AND Sales` - Show results: series with terms of Retail AND Sales, regardless of the sequence. E. g. Retail Sales, Automobile Sales Retail `Retail;Sales` - Show series with either keyword and series with both keywords while the sequence of keywords is irrelevant, equivalent to search: Sales;Retail `Retail OR Sales` - Show results: series with terms of Retail OR Sales, regardless of the sequence. E. g. Retail Sales, Retail Trade, Sales Price, Motor Vehicle Sales `Retail NOT Sales` - Narrow a search by excluding specific terms while the sequence of keywords is relevant. Show results: series with terms that include Retail, but NOT Sales. E. g. Retail Trade, Retail Price, Retail Bank `Retail Sales NOT (Hong Kong)` - Narrow a search by excluding a set of words in parentheses while the sequence of keywords in parentheses is irrelevant, equivalent to search: Retail Sales NOT (Hong Kong). Show results: series with terms that include Retail Sales, but NOT Hong Kong, such as Retail Sales YoY: China, Retail Sales YoY: United States
        :param bool strict_keyword_search: When true, will make a strict keywords search instead of fuzzy search.
        :param list[str] frequency: Frequency filter. One or more comma separated frequency code values. D - Daily W - Weekly M - Monthly Q - Quarterly H - Semi-annual Y - Annual Z - Quinquennially T - Decadal
        :param list[str] country: **DEPRECATED. Please use `geo` parameter.** Country filter. One or more comma separated country code values. See related Dictionary function to get the full list of accepted countries.
        :param list[str] source: Source filter. One or more comma separated source code values. See related Dictionary function to get the full list of accepted sources.
        :param list[str] unit: Unit filter. One or more comma separated unit code values. See related Dictionary function to get the full list of accepted units.
        :param list[str] indicator: Indicator filter. One or more comma separated indicator code values. See related Dictionary function to get full list of accepted indicators. The use the new indicators ids is recommended because the old ones are deprecated and going to be removed in the near future!
        :param list[str] region: Region filter. One or more comma separated region code values. See related Dictionary function to get the full list of accepted regions.
        :param bool subscribed_only: Show only results for subscribed series when set to `true`. By default show results for all the series found.
        :param bool key_only: Show only 'key' series when set to `true`.
        :param bool new_only: Show only series created less than 1 month ago when set to `true`.
        :param bool name_only: This filter related with the `keyword` filter. If it's `true` keyword search will be searched only in series name instead of all series attributes.
        :param date start_date_before: Will return series with first observation before `start_date_before`
        :param date end_date_after: Will return series with last observation after `end_date_after`
        :param date created_after: Will return entries created after `created_after` date
        :param date updated_after: Will return series last time updated after `updated_after` date and time
        :param date timepoints_updated_after:  Will return series containing timepoints' last time updated after updated_after date and time
        :param list[str] geo: Geo filter. One or more comma separated geo id values. See related Dictionary function to get the full list of accepted geo ids.
        :param list[str] status: Status filter. One or more comma separated status code values. When not explicitly set, defaults to T.  T - Active C - Discontinued B - Rebased D - On-Demand
        :param list[str] data_source: Data source for series search operation. When CEIC is selected, we search for CEIC series only. When USER-IMPORTED is selected, we search only for user imported series
        :param list[str] series: List of series
        :param bool with_vintage_enabled_only: If it is `true` result will contain ONLY vintage enabled series
        :param bool headline_only: Show only 'headline' series when set to `true`.
        :param list[str] topic: Topic filter. One or more comma separated topic code values.
        :param list[str] section: Section filter. One or more comma separated section code values.
        :param list[str] table: Table filter. One or more comma separated table code values.
        :param list[str] order: Sort order. Default is `relevance`.
        :param list[str] direction: Sort order direction. Default is `asc`. Accepted values: `asc` - ascending `desc` - descending
        :param list[str] filter_id: Filter ID used to define a subset of data over which the search will be executed. When combined with additional search criterion, the result will be an intesection of both.
        :param bool with_replacements_metadata: If it is `true` result will contain replacements metadata not only list of id`s
        :param bool forecast_only: If it is `true` result will only contain series with forecast
        :param bool with_release_only: If it is `true` result will only contain series with released schedule
        :param bool with_replacements_only: If it is `true` result will only contain series with suggestions
        :param bool with_observations_only: If it is `true` result will not contain series without observations
        :param bool with_continuous_only: If set to `true` results will contain only series with available historical extensions
        :param list[str] facet: List of facets to return
        :param date release_date_from: Will return releases with first observation before `release_date_from`
        :param date release_date_to: Will return releases with last observation after `release_date_to`
        :param list[str] release_status: List of release statuses to return
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'limit', 'offset', 'layout', 'database', 'keyword', 'strict_keyword_search', 'frequency', 'country', 'source', 'unit', 'indicator', 'region', 'subscribed_only', 'key_only', 'new_only', 'name_only', 'start_date_before', 'end_date_after', 'created_after', 'updated_after', 'timepoints_updated_after', 'geo', 'status', 'data_source', 'series', 'with_vintage_enabled_only', 'headline_only', 'topic', 'section', 'table', 'order', 'direction', 'filter_id', 'with_replacements_metadata', 'forecast_only', 'with_release_only', 'with_replacements_only', 'with_observations_only', 'with_continuous_only', 'facet', 'release_date_from', 'release_date_to', 'release_status']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        if self.api_client.client_side_validation and ('limit' in params and params['limit'] > 100):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `releases_options`, must be a value less than or equal to `100`")  # noqa: E501
        if self.api_client.client_side_validation and ('limit' in params and params['limit'] < 1):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `releases_options`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'layout' in params:
            query_params.append(('layout', params['layout']))  # noqa: E501
            collection_formats['layout'] = 'csv'  # noqa: E501
        if 'database' in params:
            query_params.append(('database', params['database']))  # noqa: E501
            collection_formats['database'] = 'csv'  # noqa: E501
        if 'keyword' in params:
            query_params.append(('keyword', params['keyword']))  # noqa: E501
        if 'strict_keyword_search' in params:
            query_params.append(('strict_keyword_search', params['strict_keyword_search']))  # noqa: E501
        if 'frequency' in params:
            query_params.append(('frequency', params['frequency']))  # noqa: E501
            collection_formats['frequency'] = 'csv'  # noqa: E501
        if 'country' in params:
            query_params.append(('country', params['country']))  # noqa: E501
            collection_formats['country'] = 'csv'  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
            collection_formats['source'] = 'csv'  # noqa: E501
        if 'unit' in params:
            query_params.append(('unit', params['unit']))  # noqa: E501
            collection_formats['unit'] = 'csv'  # noqa: E501
        if 'indicator' in params:
            query_params.append(('indicator', params['indicator']))  # noqa: E501
            collection_formats['indicator'] = 'csv'  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
            collection_formats['region'] = 'csv'  # noqa: E501
        if 'subscribed_only' in params:
            query_params.append(('subscribed_only', params['subscribed_only']))  # noqa: E501
        if 'key_only' in params:
            query_params.append(('key_only', params['key_only']))  # noqa: E501
        if 'new_only' in params:
            query_params.append(('new_only', params['new_only']))  # noqa: E501
        if 'name_only' in params:
            query_params.append(('name_only', params['name_only']))  # noqa: E501
        if 'start_date_before' in params:
            query_params.append(('start_date_before', params['start_date_before']))  # noqa: E501
        if 'end_date_after' in params:
            query_params.append(('end_date_after', params['end_date_after']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('created_after', params['created_after']))  # noqa: E501
        if 'updated_after' in params:
            query_params.append(('updated_after', params['updated_after']))  # noqa: E501
        if 'timepoints_updated_after' in params:
            query_params.append(('timepoints_updated_after', params['timepoints_updated_after']))  # noqa: E501
        if 'geo' in params:
            query_params.append(('geo', params['geo']))  # noqa: E501
            collection_formats['geo'] = 'csv'  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
            collection_formats['status'] = 'csv'  # noqa: E501
        if 'data_source' in params:
            query_params.append(('data_source', params['data_source']))  # noqa: E501
            collection_formats['data_source'] = 'csv'  # noqa: E501
        if 'series' in params:
            query_params.append(('series', params['series']))  # noqa: E501
            collection_formats['series'] = 'csv'  # noqa: E501
        if 'with_vintage_enabled_only' in params:
            query_params.append(('with_vintage_enabled_only', params['with_vintage_enabled_only']))  # noqa: E501
        if 'headline_only' in params:
            query_params.append(('headline_only', params['headline_only']))  # noqa: E501
        if 'topic' in params:
            query_params.append(('topic', params['topic']))  # noqa: E501
            collection_formats['topic'] = 'csv'  # noqa: E501
        if 'section' in params:
            query_params.append(('section', params['section']))  # noqa: E501
            collection_formats['section'] = 'csv'  # noqa: E501
        if 'table' in params:
            query_params.append(('table', params['table']))  # noqa: E501
            collection_formats['table'] = 'csv'  # noqa: E501
        if 'order' in params:
            query_params.append(('order', params['order']))  # noqa: E501
            collection_formats['order'] = 'csv'  # noqa: E501
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501
            collection_formats['direction'] = 'csv'  # noqa: E501
        if 'filter_id' in params:
            query_params.append(('filter_id', params['filter_id']))  # noqa: E501
            collection_formats['filter_id'] = 'csv'  # noqa: E501
        if 'with_replacements_metadata' in params:
            query_params.append(('with_replacements_metadata', params['with_replacements_metadata']))  # noqa: E501
        if 'forecast_only' in params:
            query_params.append(('forecast_only', params['forecast_only']))  # noqa: E501
        if 'with_release_only' in params:
            query_params.append(('with_release_only', params['with_release_only']))  # noqa: E501
        if 'with_replacements_only' in params:
            query_params.append(('with_replacements_only', params['with_replacements_only']))  # noqa: E501
        if 'with_observations_only' in params:
            query_params.append(('with_observations_only', params['with_observations_only']))  # noqa: E501
        if 'with_continuous_only' in params:
            query_params.append(('with_continuous_only', params['with_continuous_only']))  # noqa: E501
        if 'facet' in params:
            query_params.append(('facet', params['facet']))  # noqa: E501
            collection_formats['facet'] = 'csv'  # noqa: E501
        if 'release_date_from' in params:
            query_params.append(('release_date_from', params['release_date_from']))  # noqa: E501
        if 'release_date_to' in params:
            query_params.append(('release_date_to', params['release_date_to']))  # noqa: E501
        if 'release_status' in params:
            query_params.append(('release_status', params['release_status']))  # noqa: E501
            collection_formats['release_status'] = 'csv'  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/releases', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_series_id_options(self, id, **kwargs):  # noqa: E501
        """releases_series_id_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_series_id_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Series ID or Series Code to return. Accepts only one series ID or series Code. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param date release_date_from: Will return releases with first observation before `release_date_from`
        :param date release_date_to: Will return releases with last observation after `release_date_to`
        :param list[str] release_status: List of release statuses to return
        :param float offset: The offset from which the records will be returned. Used to get the next set of records when the limit is reached.
        :param float limit: Number of records to return in the range 1 - 100. Default is 100.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_series_id_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_series_id_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def releases_series_id_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """releases_series_id_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_series_id_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Series ID or Series Code to return. Accepts only one series ID or series Code. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param date release_date_from: Will return releases with first observation before `release_date_from`
        :param date release_date_to: Will return releases with last observation after `release_date_to`
        :param list[str] release_status: List of release statuses to return
        :param float offset: The offset from which the records will be returned. Used to get the next set of records when the limit is reached.
        :param float limit: Number of records to return in the range 1 - 100. Default is 100.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'release_date_from', 'release_date_to', 'release_status', 'offset', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_series_id_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `releases_series_id_options`")  # noqa: E501

        if self.api_client.client_side_validation and ('limit' in params and params['limit'] > 100):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `releases_series_id_options`, must be a value less than or equal to `100`")  # noqa: E501
        if self.api_client.client_side_validation and ('limit' in params and params['limit'] < 1):  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `releases_series_id_options`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'release_date_from' in params:
            query_params.append(('release_date_from', params['release_date_from']))  # noqa: E501
        if 'release_date_to' in params:
            query_params.append(('release_date_to', params['release_date_to']))  # noqa: E501
        if 'release_status' in params:
            query_params.append(('release_status', params['release_status']))  # noqa: E501
            collection_formats['release_status'] = 'csv'  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/releases/series/{id}', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def series_id_data_options(self, id, **kwargs):  # noqa: E501
        """series_id_data_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.series_id_data_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Series ID or Series Code to return. Accepts only one series ID or series Code. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str vintage_revision_date: When specified will return vintages snapshot at the specified revision date (YYYY-MM-DD).
        :param int count: Limit the amount of latest time-points returned, by the number specified.
        :param date start_date: Limits the start date after which the time-points will be returned.
        :param date end_date: Limits the end date before which the time-points will be returned.
        :param datetime updated_after: Returns only the updated time-points after the date specified.
        :param bool blank_observations: If it's set to true, empty time-points will be returned
        :param str time_points_status: Time points filter. One or more comma separated status code values. When not explicitly set, defaults to T. T - Active X - Deleted
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.series_id_data_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.series_id_data_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def series_id_data_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """series_id_data_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.series_id_data_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Series ID or Series Code to return. Accepts only one series ID or series Code. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str vintage_revision_date: When specified will return vintages snapshot at the specified revision date (YYYY-MM-DD).
        :param int count: Limit the amount of latest time-points returned, by the number specified.
        :param date start_date: Limits the start date after which the time-points will be returned.
        :param date end_date: Limits the end date before which the time-points will be returned.
        :param datetime updated_after: Returns only the updated time-points after the date specified.
        :param bool blank_observations: If it's set to true, empty time-points will be returned
        :param str time_points_status: Time points filter. One or more comma separated status code values. When not explicitly set, defaults to T. T - Active X - Deleted
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'vintage_revision_date', 'count', 'start_date', 'end_date', 'updated_after', 'blank_observations', 'time_points_status']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method series_id_data_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `series_id_data_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'vintage_revision_date' in params:
            query_params.append(('vintage_revision_date', params['vintage_revision_date']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'updated_after' in params:
            query_params.append(('updated_after', params['updated_after']))  # noqa: E501
        if 'blank_observations' in params:
            query_params.append(('blank_observations', params['blank_observations']))  # noqa: E501
        if 'time_points_status' in params:
            query_params.append(('time_points_status', params['time_points_status']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/series/{id}/data', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def series_id_earliest_options(self, id, **kwargs):  # noqa: E501
        """series_id_earliest_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.series_id_earliest_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Series ID or Series Code to return. Accepts only one series ID or series Code. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str vintage_revision_date: When specified will return vintages snapshot at the specified revision date (YYYY-MM-DD).
        :param int count: Limit the amount of latest time-points returned, by the number specified.
        :param date start_date: Limits the start date after which the time-points will be returned.
        :param date end_date: Limits the end date before which the time-points will be returned.
        :param datetime updated_after: Returns only the updated time-points after the date specified.
        :param bool blank_observations: If it's set to true, empty time-points will be returned
        :param str time_points_status: Time points filter. One or more comma separated status code values. When not explicitly set, defaults to T. T - Active X - Deleted
        :param bool with_replacements_metadata: If it is `true` result will contain replacements metadata not only list of id`s
        :param bool forecast_only: If it is `true` result will only contain series with forecast
        :param bool with_release_only: If it is `true` result will only contain series with released schedule
        :param bool with_replacements_only: If it is `true` result will only contain series with suggestions
        :param bool with_observations_only: If it is `true` result will not contain series without observations
        :param bool with_continuous_only: If set to `true` results will contain only series with available historical extensions
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.series_id_earliest_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.series_id_earliest_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def series_id_earliest_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """series_id_earliest_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.series_id_earliest_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Series ID or Series Code to return. Accepts only one series ID or series Code. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str vintage_revision_date: When specified will return vintages snapshot at the specified revision date (YYYY-MM-DD).
        :param int count: Limit the amount of latest time-points returned, by the number specified.
        :param date start_date: Limits the start date after which the time-points will be returned.
        :param date end_date: Limits the end date before which the time-points will be returned.
        :param datetime updated_after: Returns only the updated time-points after the date specified.
        :param bool blank_observations: If it's set to true, empty time-points will be returned
        :param str time_points_status: Time points filter. One or more comma separated status code values. When not explicitly set, defaults to T. T - Active X - Deleted
        :param bool with_replacements_metadata: If it is `true` result will contain replacements metadata not only list of id`s
        :param bool forecast_only: If it is `true` result will only contain series with forecast
        :param bool with_release_only: If it is `true` result will only contain series with released schedule
        :param bool with_replacements_only: If it is `true` result will only contain series with suggestions
        :param bool with_observations_only: If it is `true` result will not contain series without observations
        :param bool with_continuous_only: If set to `true` results will contain only series with available historical extensions
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'vintage_revision_date', 'count', 'start_date', 'end_date', 'updated_after', 'blank_observations', 'time_points_status', 'with_replacements_metadata', 'forecast_only', 'with_release_only', 'with_replacements_only', 'with_observations_only', 'with_continuous_only']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method series_id_earliest_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `series_id_earliest_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'vintage_revision_date' in params:
            query_params.append(('vintage_revision_date', params['vintage_revision_date']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'updated_after' in params:
            query_params.append(('updated_after', params['updated_after']))  # noqa: E501
        if 'blank_observations' in params:
            query_params.append(('blank_observations', params['blank_observations']))  # noqa: E501
        if 'time_points_status' in params:
            query_params.append(('time_points_status', params['time_points_status']))  # noqa: E501
        if 'with_replacements_metadata' in params:
            query_params.append(('with_replacements_metadata', params['with_replacements_metadata']))  # noqa: E501
        if 'forecast_only' in params:
            query_params.append(('forecast_only', params['forecast_only']))  # noqa: E501
        if 'with_release_only' in params:
            query_params.append(('with_release_only', params['with_release_only']))  # noqa: E501
        if 'with_replacements_only' in params:
            query_params.append(('with_replacements_only', params['with_replacements_only']))  # noqa: E501
        if 'with_observations_only' in params:
            query_params.append(('with_observations_only', params['with_observations_only']))  # noqa: E501
        if 'with_continuous_only' in params:
            query_params.append(('with_continuous_only', params['with_continuous_only']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/series/{id}/earliest', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def series_id_metadata_options(self, id, **kwargs):  # noqa: E501
        """series_id_metadata_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.series_id_metadata_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Series ID or Series Code to return. Accepts only one series ID or series Code. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str vintage_revision_date: When specified will return vintages snapshot at the specified revision date (YYYY-MM-DD).
        :param bool with_replacements_metadata: If it is `true` result will contain replacements metadata not only list of id`s
        :param bool forecast_only: If it is `true` result will only contain series with forecast
        :param bool with_release_only: If it is `true` result will only contain series with released schedule
        :param bool with_replacements_only: If it is `true` result will only contain series with suggestions
        :param bool with_observations_only: If it is `true` result will not contain series without observations
        :param bool with_continuous_only: If set to `true` results will contain only series with available historical extensions
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.series_id_metadata_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.series_id_metadata_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def series_id_metadata_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """series_id_metadata_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.series_id_metadata_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Series ID or Series Code to return. Accepts only one series ID or series Code. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str vintage_revision_date: When specified will return vintages snapshot at the specified revision date (YYYY-MM-DD).
        :param bool with_replacements_metadata: If it is `true` result will contain replacements metadata not only list of id`s
        :param bool forecast_only: If it is `true` result will only contain series with forecast
        :param bool with_release_only: If it is `true` result will only contain series with released schedule
        :param bool with_replacements_only: If it is `true` result will only contain series with suggestions
        :param bool with_observations_only: If it is `true` result will not contain series without observations
        :param bool with_continuous_only: If set to `true` results will contain only series with available historical extensions
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'vintage_revision_date', 'with_replacements_metadata', 'forecast_only', 'with_release_only', 'with_replacements_only', 'with_observations_only', 'with_continuous_only']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method series_id_metadata_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `series_id_metadata_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'vintage_revision_date' in params:
            query_params.append(('vintage_revision_date', params['vintage_revision_date']))  # noqa: E501
        if 'with_replacements_metadata' in params:
            query_params.append(('with_replacements_metadata', params['with_replacements_metadata']))  # noqa: E501
        if 'forecast_only' in params:
            query_params.append(('forecast_only', params['forecast_only']))  # noqa: E501
        if 'with_release_only' in params:
            query_params.append(('with_release_only', params['with_release_only']))  # noqa: E501
        if 'with_replacements_only' in params:
            query_params.append(('with_replacements_only', params['with_replacements_only']))  # noqa: E501
        if 'with_observations_only' in params:
            query_params.append(('with_observations_only', params['with_observations_only']))  # noqa: E501
        if 'with_continuous_only' in params:
            query_params.append(('with_continuous_only', params['with_continuous_only']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/series/{id}/metadata', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def series_id_options(self, id, **kwargs):  # noqa: E501
        """series_id_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.series_id_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Series ID or Series Code to return. Accepts only one series ID or series Code. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str vintage_revision_date: When specified will return vintages snapshot at the specified revision date (YYYY-MM-DD).
        :param int count: Limit the amount of latest time-points returned, by the number specified.
        :param date start_date: Limits the start date after which the time-points will be returned.
        :param date end_date: Limits the end date before which the time-points will be returned.
        :param datetime updated_after: Returns only the updated time-points after the date specified.
        :param bool blank_observations: If it's set to true, empty time-points will be returned
        :param str time_points_status: Time points filter. One or more comma separated status code values. When not explicitly set, defaults to T. T - Active X - Deleted
        :param bool with_replacements_metadata: If it is `true` result will contain replacements metadata not only list of id`s
        :param bool forecast_only: If it is `true` result will only contain series with forecast
        :param bool with_release_only: If it is `true` result will only contain series with released schedule
        :param bool with_replacements_only: If it is `true` result will only contain series with suggestions
        :param bool with_observations_only: If it is `true` result will not contain series without observations
        :param bool with_continuous_only: If set to `true` results will contain only series with available historical extensions
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.series_id_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.series_id_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def series_id_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """series_id_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.series_id_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Series ID or Series Code to return. Accepts only one series ID or series Code. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str vintage_revision_date: When specified will return vintages snapshot at the specified revision date (YYYY-MM-DD).
        :param int count: Limit the amount of latest time-points returned, by the number specified.
        :param date start_date: Limits the start date after which the time-points will be returned.
        :param date end_date: Limits the end date before which the time-points will be returned.
        :param datetime updated_after: Returns only the updated time-points after the date specified.
        :param bool blank_observations: If it's set to true, empty time-points will be returned
        :param str time_points_status: Time points filter. One or more comma separated status code values. When not explicitly set, defaults to T. T - Active X - Deleted
        :param bool with_replacements_metadata: If it is `true` result will contain replacements metadata not only list of id`s
        :param bool forecast_only: If it is `true` result will only contain series with forecast
        :param bool with_release_only: If it is `true` result will only contain series with released schedule
        :param bool with_replacements_only: If it is `true` result will only contain series with suggestions
        :param bool with_observations_only: If it is `true` result will not contain series without observations
        :param bool with_continuous_only: If set to `true` results will contain only series with available historical extensions
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'vintage_revision_date', 'count', 'start_date', 'end_date', 'updated_after', 'blank_observations', 'time_points_status', 'with_replacements_metadata', 'forecast_only', 'with_release_only', 'with_replacements_only', 'with_observations_only', 'with_continuous_only']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method series_id_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `series_id_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'vintage_revision_date' in params:
            query_params.append(('vintage_revision_date', params['vintage_revision_date']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'updated_after' in params:
            query_params.append(('updated_after', params['updated_after']))  # noqa: E501
        if 'blank_observations' in params:
            query_params.append(('blank_observations', params['blank_observations']))  # noqa: E501
        if 'time_points_status' in params:
            query_params.append(('time_points_status', params['time_points_status']))  # noqa: E501
        if 'with_replacements_metadata' in params:
            query_params.append(('with_replacements_metadata', params['with_replacements_metadata']))  # noqa: E501
        if 'forecast_only' in params:
            query_params.append(('forecast_only', params['forecast_only']))  # noqa: E501
        if 'with_release_only' in params:
            query_params.append(('with_release_only', params['with_release_only']))  # noqa: E501
        if 'with_replacements_only' in params:
            query_params.append(('with_replacements_only', params['with_replacements_only']))  # noqa: E501
        if 'with_observations_only' in params:
            query_params.append(('with_observations_only', params['with_observations_only']))  # noqa: E501
        if 'with_continuous_only' in params:
            query_params.append(('with_continuous_only', params['with_continuous_only']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/series/{id}', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def series_id_vintages_dates_options(self, id, **kwargs):  # noqa: E501
        """series_id_vintages_dates_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.series_id_vintages_dates_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Series ID or Series Code to return. Accepts only one series ID or series Code. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str vintage_revision_date: When specified will return vintages snapshot at the specified revision date (YYYY-MM-DD).
        :param int count: Limit the amount of latest time-points returned, by the number specified.
        :param date start_date: Limits the start date after which the time-points will be returned.
        :param date end_date: Limits the end date before which the time-points will be returned.
        :param datetime updated_after: Returns only the updated time-points after the date specified.
        :param bool blank_observations: If it's set to true, empty time-points will be returned
        :param str time_points_status: Time points filter. One or more comma separated status code values. When not explicitly set, defaults to T. T - Active X - Deleted
        :param bool with_replacements_metadata: If it is `true` result will contain replacements metadata not only list of id`s
        :param bool forecast_only: If it is `true` result will only contain series with forecast
        :param bool with_release_only: If it is `true` result will only contain series with released schedule
        :param bool with_replacements_only: If it is `true` result will only contain series with suggestions
        :param bool with_observations_only: If it is `true` result will not contain series without observations
        :param bool with_continuous_only: If set to `true` results will contain only series with available historical extensions
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.series_id_vintages_dates_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.series_id_vintages_dates_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def series_id_vintages_dates_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """series_id_vintages_dates_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.series_id_vintages_dates_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Series ID or Series Code to return. Accepts only one series ID or series Code. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str vintage_revision_date: When specified will return vintages snapshot at the specified revision date (YYYY-MM-DD).
        :param int count: Limit the amount of latest time-points returned, by the number specified.
        :param date start_date: Limits the start date after which the time-points will be returned.
        :param date end_date: Limits the end date before which the time-points will be returned.
        :param datetime updated_after: Returns only the updated time-points after the date specified.
        :param bool blank_observations: If it's set to true, empty time-points will be returned
        :param str time_points_status: Time points filter. One or more comma separated status code values. When not explicitly set, defaults to T. T - Active X - Deleted
        :param bool with_replacements_metadata: If it is `true` result will contain replacements metadata not only list of id`s
        :param bool forecast_only: If it is `true` result will only contain series with forecast
        :param bool with_release_only: If it is `true` result will only contain series with released schedule
        :param bool with_replacements_only: If it is `true` result will only contain series with suggestions
        :param bool with_observations_only: If it is `true` result will not contain series without observations
        :param bool with_continuous_only: If set to `true` results will contain only series with available historical extensions
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'vintage_revision_date', 'count', 'start_date', 'end_date', 'updated_after', 'blank_observations', 'time_points_status', 'with_replacements_metadata', 'forecast_only', 'with_release_only', 'with_replacements_only', 'with_observations_only', 'with_continuous_only']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method series_id_vintages_dates_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `series_id_vintages_dates_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'vintage_revision_date' in params:
            query_params.append(('vintage_revision_date', params['vintage_revision_date']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'updated_after' in params:
            query_params.append(('updated_after', params['updated_after']))  # noqa: E501
        if 'blank_observations' in params:
            query_params.append(('blank_observations', params['blank_observations']))  # noqa: E501
        if 'time_points_status' in params:
            query_params.append(('time_points_status', params['time_points_status']))  # noqa: E501
        if 'with_replacements_metadata' in params:
            query_params.append(('with_replacements_metadata', params['with_replacements_metadata']))  # noqa: E501
        if 'forecast_only' in params:
            query_params.append(('forecast_only', params['forecast_only']))  # noqa: E501
        if 'with_release_only' in params:
            query_params.append(('with_release_only', params['with_release_only']))  # noqa: E501
        if 'with_replacements_only' in params:
            query_params.append(('with_replacements_only', params['with_replacements_only']))  # noqa: E501
        if 'with_observations_only' in params:
            query_params.append(('with_observations_only', params['with_observations_only']))  # noqa: E501
        if 'with_continuous_only' in params:
            query_params.append(('with_continuous_only', params['with_continuous_only']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/series/{id}/vintages/dates', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def series_id_vintages_options(self, id, **kwargs):  # noqa: E501
        """series_id_vintages_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.series_id_vintages_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Series ID or Series Code to return. Accepts only one series ID or series Code. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str vintage_revision_date: When specified will return vintages snapshot at the specified revision date (YYYY-MM-DD).
        :param int count: Limit the amount of latest time-points returned, by the number specified.
        :param date start_date: Limits the start date after which the time-points will be returned.
        :param date end_date: Limits the end date before which the time-points will be returned.
        :param datetime updated_after: Returns only the updated time-points after the date specified.
        :param bool blank_observations: If it's set to true, empty time-points will be returned
        :param str time_points_status: Time points filter. One or more comma separated status code values. When not explicitly set, defaults to T. T - Active X - Deleted
        :param bool with_replacements_metadata: If it is `true` result will contain replacements metadata not only list of id`s
        :param bool forecast_only: If it is `true` result will only contain series with forecast
        :param bool with_release_only: If it is `true` result will only contain series with released schedule
        :param bool with_replacements_only: If it is `true` result will only contain series with suggestions
        :param bool with_observations_only: If it is `true` result will not contain series without observations
        :param bool with_continuous_only: If set to `true` results will contain only series with available historical extensions
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.series_id_vintages_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.series_id_vintages_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def series_id_vintages_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """series_id_vintages_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.series_id_vintages_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Series ID or Series Code to return. Accepts only one series ID or series Code. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str vintage_revision_date: When specified will return vintages snapshot at the specified revision date (YYYY-MM-DD).
        :param int count: Limit the amount of latest time-points returned, by the number specified.
        :param date start_date: Limits the start date after which the time-points will be returned.
        :param date end_date: Limits the end date before which the time-points will be returned.
        :param datetime updated_after: Returns only the updated time-points after the date specified.
        :param bool blank_observations: If it's set to true, empty time-points will be returned
        :param str time_points_status: Time points filter. One or more comma separated status code values. When not explicitly set, defaults to T. T - Active X - Deleted
        :param bool with_replacements_metadata: If it is `true` result will contain replacements metadata not only list of id`s
        :param bool forecast_only: If it is `true` result will only contain series with forecast
        :param bool with_release_only: If it is `true` result will only contain series with released schedule
        :param bool with_replacements_only: If it is `true` result will only contain series with suggestions
        :param bool with_observations_only: If it is `true` result will not contain series without observations
        :param bool with_continuous_only: If set to `true` results will contain only series with available historical extensions
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'vintage_revision_date', 'count', 'start_date', 'end_date', 'updated_after', 'blank_observations', 'time_points_status', 'with_replacements_metadata', 'forecast_only', 'with_release_only', 'with_replacements_only', 'with_observations_only', 'with_continuous_only']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method series_id_vintages_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `series_id_vintages_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'vintage_revision_date' in params:
            query_params.append(('vintage_revision_date', params['vintage_revision_date']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'updated_after' in params:
            query_params.append(('updated_after', params['updated_after']))  # noqa: E501
        if 'blank_observations' in params:
            query_params.append(('blank_observations', params['blank_observations']))  # noqa: E501
        if 'time_points_status' in params:
            query_params.append(('time_points_status', params['time_points_status']))  # noqa: E501
        if 'with_replacements_metadata' in params:
            query_params.append(('with_replacements_metadata', params['with_replacements_metadata']))  # noqa: E501
        if 'forecast_only' in params:
            query_params.append(('forecast_only', params['forecast_only']))  # noqa: E501
        if 'with_release_only' in params:
            query_params.append(('with_release_only', params['with_release_only']))  # noqa: E501
        if 'with_replacements_only' in params:
            query_params.append(('with_replacements_only', params['with_replacements_only']))  # noqa: E501
        if 'with_observations_only' in params:
            query_params.append(('with_observations_only', params['with_observations_only']))  # noqa: E501
        if 'with_continuous_only' in params:
            query_params.append(('with_continuous_only', params['with_continuous_only']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/series/{id}/vintages', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def series_id_visual_options(self, id, **kwargs):  # noqa: E501
        """series_id_visual_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.series_id_visual_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Series ID or Series Code to return. Accepts only one series ID or series Code. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str vintage_revision_date: When specified will return vintages snapshot at the specified revision date (YYYY-MM-DD).
        :param bool with_replacements_metadata: If it is `true` result will contain replacements metadata not only list of id`s
        :param bool forecast_only: If it is `true` result will only contain series with forecast
        :param bool with_release_only: If it is `true` result will only contain series with released schedule
        :param bool with_replacements_only: If it is `true` result will only contain series with suggestions
        :param bool with_observations_only: If it is `true` result will not contain series without observations
        :param bool with_continuous_only: If set to `true` results will contain only series with available historical extensions
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.series_id_visual_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.series_id_visual_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def series_id_visual_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """series_id_visual_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.series_id_visual_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Series ID or Series Code to return. Accepts only one series ID or series Code. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str vintage_revision_date: When specified will return vintages snapshot at the specified revision date (YYYY-MM-DD).
        :param bool with_replacements_metadata: If it is `true` result will contain replacements metadata not only list of id`s
        :param bool forecast_only: If it is `true` result will only contain series with forecast
        :param bool with_release_only: If it is `true` result will only contain series with released schedule
        :param bool with_replacements_only: If it is `true` result will only contain series with suggestions
        :param bool with_observations_only: If it is `true` result will not contain series without observations
        :param bool with_continuous_only: If set to `true` results will contain only series with available historical extensions
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'vintage_revision_date', 'with_replacements_metadata', 'forecast_only', 'with_release_only', 'with_replacements_only', 'with_observations_only', 'with_continuous_only']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method series_id_visual_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `series_id_visual_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'vintage_revision_date' in params:
            query_params.append(('vintage_revision_date', params['vintage_revision_date']))  # noqa: E501
        if 'with_replacements_metadata' in params:
            query_params.append(('with_replacements_metadata', params['with_replacements_metadata']))  # noqa: E501
        if 'forecast_only' in params:
            query_params.append(('forecast_only', params['forecast_only']))  # noqa: E501
        if 'with_release_only' in params:
            query_params.append(('with_release_only', params['with_release_only']))  # noqa: E501
        if 'with_replacements_only' in params:
            query_params.append(('with_replacements_only', params['with_replacements_only']))  # noqa: E501
        if 'with_observations_only' in params:
            query_params.append(('with_observations_only', params['with_observations_only']))  # noqa: E501
        if 'with_continuous_only' in params:
            query_params.append(('with_continuous_only', params['with_continuous_only']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/series/{id}/visual', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def series_search_options(self, **kwargs):  # noqa: E501
        """series_search_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.series_search_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.series_search_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.series_search_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def series_search_options_with_http_info(self, **kwargs):  # noqa: E501
        """series_search_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.series_search_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method series_search_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/series/search', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def subscriptions_options(self, **kwargs):  # noqa: E501
        """subscriptions_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.subscriptions_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.subscriptions_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.subscriptions_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def subscriptions_options_with_http_info(self, **kwargs):  # noqa: E501
        """subscriptions_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.subscriptions_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method subscriptions_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/subscriptions', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def userdefined_series_clone_options(self, **kwargs):  # noqa: E501
        """userdefined_series_clone_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userdefined_series_clone_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.userdefined_series_clone_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.userdefined_series_clone_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def userdefined_series_clone_options_with_http_info(self, **kwargs):  # noqa: E501
        """userdefined_series_clone_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userdefined_series_clone_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method userdefined_series_clone_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/userdefined/series/clone', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def userdefined_series_id_data_options(self, id, **kwargs):  # noqa: E501
        """userdefined_series_id_data_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userdefined_series_id_data_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Series ID or Series Code to return. Accepts only one series ID or series Code. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str vintage_revision_date: When specified will return vintages snapshot at the specified revision date (YYYY-MM-DD).
        :param int count: Limit the amount of latest time-points returned, by the number specified.
        :param date start_date: Limits the start date after which the time-points will be returned.
        :param date end_date: Limits the end date before which the time-points will be returned.
        :param datetime updated_after: Returns only the updated time-points after the date specified.
        :param bool blank_observations: If it's set to true, empty time-points will be returned
        :param str time_points_status: Time points filter. One or more comma separated status code values. When not explicitly set, defaults to T. T - Active X - Deleted
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.userdefined_series_id_data_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.userdefined_series_id_data_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def userdefined_series_id_data_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """userdefined_series_id_data_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userdefined_series_id_data_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Series ID or Series Code to return. Accepts only one series ID or series Code. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str vintage_revision_date: When specified will return vintages snapshot at the specified revision date (YYYY-MM-DD).
        :param int count: Limit the amount of latest time-points returned, by the number specified.
        :param date start_date: Limits the start date after which the time-points will be returned.
        :param date end_date: Limits the end date before which the time-points will be returned.
        :param datetime updated_after: Returns only the updated time-points after the date specified.
        :param bool blank_observations: If it's set to true, empty time-points will be returned
        :param str time_points_status: Time points filter. One or more comma separated status code values. When not explicitly set, defaults to T. T - Active X - Deleted
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'vintage_revision_date', 'count', 'start_date', 'end_date', 'updated_after', 'blank_observations', 'time_points_status']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method userdefined_series_id_data_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `userdefined_series_id_data_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'vintage_revision_date' in params:
            query_params.append(('vintage_revision_date', params['vintage_revision_date']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'updated_after' in params:
            query_params.append(('updated_after', params['updated_after']))  # noqa: E501
        if 'blank_observations' in params:
            query_params.append(('blank_observations', params['blank_observations']))  # noqa: E501
        if 'time_points_status' in params:
            query_params.append(('time_points_status', params['time_points_status']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/userdefined/series/{id}/data', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def userdefined_series_id_timepoints_date_options(self, id, **kwargs):  # noqa: E501
        """userdefined_series_id_timepoints_date_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userdefined_series_id_timepoints_date_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Series ID or Series Code to return. Accepts only one series ID or series Code. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str vintage_revision_date: When specified will return vintages snapshot at the specified revision date (YYYY-MM-DD).
        :param int count: Limit the amount of latest time-points returned, by the number specified.
        :param date start_date: Limits the start date after which the time-points will be returned.
        :param date end_date: Limits the end date before which the time-points will be returned.
        :param datetime updated_after: Returns only the updated time-points after the date specified.
        :param bool blank_observations: If it's set to true, empty time-points will be returned
        :param str time_points_status: Time points filter. One or more comma separated status code values. When not explicitly set, defaults to T. T - Active X - Deleted
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.userdefined_series_id_timepoints_date_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.userdefined_series_id_timepoints_date_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def userdefined_series_id_timepoints_date_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """userdefined_series_id_timepoints_date_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userdefined_series_id_timepoints_date_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Series ID or Series Code to return. Accepts only one series ID or series Code. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str vintage_revision_date: When specified will return vintages snapshot at the specified revision date (YYYY-MM-DD).
        :param int count: Limit the amount of latest time-points returned, by the number specified.
        :param date start_date: Limits the start date after which the time-points will be returned.
        :param date end_date: Limits the end date before which the time-points will be returned.
        :param datetime updated_after: Returns only the updated time-points after the date specified.
        :param bool blank_observations: If it's set to true, empty time-points will be returned
        :param str time_points_status: Time points filter. One or more comma separated status code values. When not explicitly set, defaults to T. T - Active X - Deleted
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'vintage_revision_date', 'count', 'start_date', 'end_date', 'updated_after', 'blank_observations', 'time_points_status']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method userdefined_series_id_timepoints_date_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `userdefined_series_id_timepoints_date_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'vintage_revision_date' in params:
            query_params.append(('vintage_revision_date', params['vintage_revision_date']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'updated_after' in params:
            query_params.append(('updated_after', params['updated_after']))  # noqa: E501
        if 'blank_observations' in params:
            query_params.append(('blank_observations', params['blank_observations']))  # noqa: E501
        if 'time_points_status' in params:
            query_params.append(('time_points_status', params['time_points_status']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/userdefined/series/{id}/timepoints/{date}', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def userdefined_series_id_timepoints_options(self, id, **kwargs):  # noqa: E501
        """userdefined_series_id_timepoints_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userdefined_series_id_timepoints_options(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Series ID or Series Code to return. Accepts only one series ID or series Code. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str vintage_revision_date: When specified will return vintages snapshot at the specified revision date (YYYY-MM-DD).
        :param int count: Limit the amount of latest time-points returned, by the number specified.
        :param date start_date: Limits the start date after which the time-points will be returned.
        :param date end_date: Limits the end date before which the time-points will be returned.
        :param datetime updated_after: Returns only the updated time-points after the date specified.
        :param bool blank_observations: If it's set to true, empty time-points will be returned
        :param str time_points_status: Time points filter. One or more comma separated status code values. When not explicitly set, defaults to T. T - Active X - Deleted
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.userdefined_series_id_timepoints_options_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.userdefined_series_id_timepoints_options_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def userdefined_series_id_timepoints_options_with_http_info(self, id, **kwargs):  # noqa: E501
        """userdefined_series_id_timepoints_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userdefined_series_id_timepoints_options_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Series ID or Series Code to return. Accepts only one series ID or series Code. (required)
        :param str accept_language: Preferred language code in which data shall be returned. Defaults to `English` if no translation in the specified language is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str accept: Response data format. Default is `application/json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str lang: Preferred language code in which data will be returned. Defaults to `English` if no translation in the language specified is available. Can be used through the query parameter `query` or using the header `Accept-Language`.  `en` - English `zh` - Chinese `ru` - Russian `id` - Indonesian `jp` - Japanese
        :param str format: Response data format. Default is `json`. Can be used through the query parameter `format` or using the header `Accept`.
        :param str token: Access API key.
        :param bool with_model_information: If set to `true` returns the model names as part of the response.
        :param str vintage_revision_date: When specified will return vintages snapshot at the specified revision date (YYYY-MM-DD).
        :param int count: Limit the amount of latest time-points returned, by the number specified.
        :param date start_date: Limits the start date after which the time-points will be returned.
        :param date end_date: Limits the end date before which the time-points will be returned.
        :param datetime updated_after: Returns only the updated time-points after the date specified.
        :param bool blank_observations: If it's set to true, empty time-points will be returned
        :param str time_points_status: Time points filter. One or more comma separated status code values. When not explicitly set, defaults to T. T - Active X - Deleted
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'accept_language', 'accept', 'lang', 'format', 'token', 'with_model_information', 'vintage_revision_date', 'count', 'start_date', 'end_date', 'updated_after', 'blank_observations', 'time_points_status']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method userdefined_series_id_timepoints_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `userdefined_series_id_timepoints_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'with_model_information' in params:
            query_params.append(('with_model_information', params['with_model_information']))  # noqa: E501
        if 'vintage_revision_date' in params:
            query_params.append(('vintage_revision_date', params['vintage_revision_date']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'updated_after' in params:
            query_params.append(('updated_after', params['updated_after']))  # noqa: E501
        if 'blank_observations' in params:
            query_params.append(('blank_observations', params['blank_observations']))  # noqa: E501
        if 'time_points_status' in params:
            query_params.append(('time_points_status', params['time_points_status']))  # noqa: E501

        header_params = {}
        if 'accept_language' in params:
            header_params['Accept-Language'] = params['accept_language']  # noqa: E501
        if 'accept' in params:
            header_params['Accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/userdefined/series/{id}/timepoints', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def userdefined_series_options(self, **kwargs):  # noqa: E501
        """userdefined_series_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userdefined_series_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.userdefined_series_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.userdefined_series_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def userdefined_series_options_with_http_info(self, **kwargs):  # noqa: E501
        """userdefined_series_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userdefined_series_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method userdefined_series_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/userdefined/series', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def validate_credentials_options(self, **kwargs):  # noqa: E501
        """validate_credentials_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_credentials_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.validate_credentials_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.validate_credentials_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def validate_credentials_options_with_http_info(self, **kwargs):  # noqa: E501
        """validate_credentials_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_credentials_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_credentials_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/validate_credentials', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def watchlist_id_options(self, **kwargs):  # noqa: E501
        """watchlist_id_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.watchlist_id_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.watchlist_id_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.watchlist_id_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def watchlist_id_options_with_http_info(self, **kwargs):  # noqa: E501
        """watchlist_id_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.watchlist_id_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watchlist_id_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/watchlist/{id}', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def watchlist_options(self, **kwargs):  # noqa: E501
        """watchlist_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.watchlist_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.watchlist_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.watchlist_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def watchlist_options_with_http_info(self, **kwargs):  # noqa: E501
        """watchlist_options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.watchlist_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watchlist_options" % key
                )
            params[key] = val
        del params['kwargs']

        params["token"] = params["token"] if "token" in params else self._token

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CEIC_API_Authorizer', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/watchlist', 'OPTIONS',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
